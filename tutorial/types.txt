types.txt
(C) 2001 Ralph Becket <rafe@cs.mu.oz.au>
Fri Nov  9 16:47:37 EST 2001
 vim: ft=txt ts=4 sw=4 et



TYPES

Every value has a type.  For example: the numbers ... -2, -1, 0, 1, 2,
... are all of type "int"; 3.141, 2.718, and 3.0e8 are all numbers of
type "float"; 'a', 'b', 'c' are characters of type "char"; and so
forth.

The notion of type is pervasive throughout Mercury - it is a /strongly
typed/ language after all - and serves as a powerful tool, both for
debugging (Mercury just won't let you put a square peg in a round
hole), for reliability (a Mercury program will never crash because an
argument of the wrong type was passed undetected), for documentation
purposes, and last, but not least, allows the compiler to apply
powerful optimization techniques.  [XXX REF why weakly typed languages
suck?]

Mercury comes with a number of built-in primitive types and provides a
mechanism for constructing more complex types.



MERCURY'S PRIMITVE TYPES

-   The "int" type contains all the integers that can be represented
    in a word of data on the target machine architecture.  On a 32-bit
    machine, therefore, "int" spans the integers from -2^31 to
    2^31 - 1.

-   The "float" type contains all the real numbers that can be
    represented using a double-precision floating point value on the
    target machine architecture.

-   The "char" type contains all 256 ASCII characters.  "char"s are
    normally quoted, such as 'a', 'b', 'c' et cetera, but in some
    cases parentheses may also be required since the character in
    question may also be used as the name of an operator - so ('+'),
    ('-'), ('*') and ('\\')\footnote{"\" acts as an escape character
    inside quotes, just like in C strings, hence '\\' corresponds to a
    single quote character.} remove all ambiguity.

-   The "string" type contains all sequences of "char"s.  Strings are
    written enclosed in double "quotes".



COMPOUND TYPES

Say we want to construct a new type to represent the suits in a deck
of cards.  We can construct a new type for just this purpose:

    :- type suit ---> clubs ; diamonds ; hearts ; spades.

Here "suit" is the name of our new type, which has four possible
values: "clubs", "diamonds", "hearts" and "spades" (these are known as
the type /constructors/ for "suit").  The "--->" separates the type
name from its constructors, and the constructors are separated by ";"
(in Mercury, ";" is usually read as "or", so this declaration says
that a value of type "suit" must be either "clubs" or "hearts" or
"diamonds" or "spades".)

With the above declaration we can now use these new values in our
program just as if they were built-in to the language.

For example, say we also want a type to represent the cards in a deck;
we could define

    :- type card ---> card(int, suit).

This says that a value of type "card" is any structure "card(X, Y)"
where "X" is an "int" and "Y" is a "suit".  (By convention in our
program we would probably want to restrict "X" to be a number in the 
range 1 to 13.)  Thus, the seven of hearts would be represented as
"card(7, hearts)" while "card(1, spades)" would represent the ace of
spades.

Compound types are not restricted to having a single constructor.
For example, we might define

    :- type wheel ---> inflated ; flat ; burst.

        % Each wheeled vehicle constructor has one argument for the
        % state of each of its wheels.
        %
    :- type vehicle

        --->    boat

                    % bicycle(front, back)
                    %
        ;       bicycle(wheel, wheel)

                    % car(front-left, front-right,
                    %     rear-left,  rear-right)
                    %
        ;       car(wheel, wheel, wheel, wheel)

                    % lorry(cab-front-left, cab-front-right,
                    %       cab-rear-left,  cab-rear-right,
                    %       trailer-left,   trailer-right)
                    %
        ;       lorry(wheel, wheel, wheel, wheel, wheel, wheel).



RECURSIVE TYPES

Frequently, we need to be able to represent recursive types such as
lists and trees.  We can do this by using the name of the type being
defined as a constructor argument.  For example, a list of "int"s
could be defined as

    :- type int_list ---> nil ; cons(int, int_list).

("cons" is the name conventionally used to mean "list constructor";
"nil" denotes the empty list.)  So, an "int_list" is either the empty
list, "nil" or a non-empty list "cons(X, Y)" where "X" is an "int" and
"Y" is an "int_list".  The following are all examples of "int_list"
values:

    nil
    cons(3, nil)
    cons(3, cons(1, nil))
    cons(3, cons(1, cons(4, nil)))
    cons(3, cons(1, cons(4, cons(1, nil))))

We can have a type for lists of "string"s by defining

    :- type string_list ---> nil ; cons(string, string_list).

and so forth.

We could go on to construct, say, binary trees of "int"s:

    :- type int_tree ---> leaf ; branch(int, int_tree, int_tree).

or even binary trees of "int_list"s:

    :- type int_list_tree
        --->    leaf
        ;       branch(int_list, int_list_tree, int_list_tree).



PARAMETRIC TYPES AND EQUIVALENCE TYPES

Since the various list types are so similar, it would be tedious if we
had to write the same boiler-plate each time we needed a new list
type.  The solution to this is to use parametric types, where the name
of the type being defined takes one argument for each type of value we
might want to vary.

For example, our parametric list type would be defined as

    :- type list(T) ---> nil ; cons(T, list(T)).

That is, a value of type "list(T)", for any type "T", is either "nil"
or something of the form "cons(X, Y)" where "X" has type "T" and "Y"
has type "list(T)".  Type parameters are /type variables/ and, like
all variables in Mercury, should begin with a capital letter.

Now "list(int)", "list(string)", "list(list(int))", or any combination
we care to think of, are all perfectly good types.

To give another example, the binary tree datatype would be generalized
to

    :- type tree(T) ---> leaf ; branch(T, tree(T), tree(T)).

We may want to abbreviate some of these complex type names in order to
simplify our programs.  Equivalence types exists for just this
purpose and are defined as in the following examples:

    :- type ints == list(int).
    :- type strings == list(string).
    :- type ints_tree == tree(ints).

The left hand side of the "==" gives the name of the new equivalence
type and the right hand side supplies the definition.

Parametric types can take more than one argument if required;
equivalence types can also take parameters.  For example, the "map"
module in the standard library defines a type "map(K, V)"; a "map"
value is rather like a dictionary that can be used to associate values
of type "V" with keys of type "K".  A "map(string, int)" might be used
to represent a simple telephone directory, mapping names (as
"string"s) to phone numbers (represented as "int"s).  We might define
an array data type as follows:

    :- type array(T) == map(int, T).

and use it thus:

    :- type int_array == array(int).
    :- type string_array == array(string).

The key constraint on parametric and equivalence type declarations is
that all type variables appearing in the definition must also be
parameters of the type being defined.  Hence the following is not
allowed because the type variable "T" is not a parameter of
"any_list":

        % This is illegal!
        %
    :- type any_list == list(T).

The reason for this is that the mercury compiler must be able to work
out what type each value belongs to.  If types like "any_list" were
permitted then by transitivity we would have to accept that
"list(int)" and "list(string)" were equivalent, which would mean
losing all the valuable properties of a strong type system!  (Note
that this does not mean that we cannot write code that deals with both
"list(int)" values, "list(string)" values and, indeed, any "list(T)"
value at all - such things will be explained in the chapter on REF
polymorphic programming.  We can also have lists in which each list
item may have a different type; this is explained in the chapter on
REF existential types.)

Note that the constructors for each type are just that, they are not
types in their own right.  This means that the declaration

    :- type number ---> int ; float.

defines "number" to be a type with two nullary constructors, "int/0"
and "float/0", /not/ the union of the types "int" and "float"!
Mercury does not support undiscriminated union types and insists that
the various "flavours" of a type be distinguished by its constructors.
[XXX REF why dynamic typing costs?]



TYPE CONSTRUCTORS WITH NAMED FIELDS

The most common method for accessing the fields of a data constructor
is by pattern matching and unification.

However, it is often the case that you want to access fields by name,
rather than position within a constructor (indeed, in languages like
C and Java this is the /only/ way in which you can access the fields
of a structure or object.)

Mercury allows you to define structures with named fields, as the
following example shows:

    :- type person
        --->    person(
                    name        :: string,  % "Surname, First name".
                    age         :: int,     % Age in years.
                    gender      :: gender,  % `male' or `female'.
                    married     :: bool     % `yes' or `no'.
                ).

    :- type gender ---> male ; female.

If "X" is a variable of type "person", we can access its fields with
"X ^ name", "X ^ age", and "X ^ gender".  The "^" functions are
automatically generated by the compiler for you.

You can obtain a copy of a value with an updated field value as
follows:

    :- func sex_change(person) = person.

    sex_change(X) =
        X ^ gender := ( if X ^ gender = male then female else male ).

"X ^ fld := Y" means "construct a copy of "X", substituting "Y" for
the field named "fld"".  Since the result of a substitution is an 
object of the same type of the original, we can chain multiple
substitutions together; for example

    (( Hedwig
                ^ gender  := female )
                ^ married := yes )

constructs a copy of the "person" "Hedwig" with the "gender" field set
to "female" and the "married" field set to "yes".

Since substitution constructs a /new/ version of an existing value,
you cannot use it to construct the initial value in a sequence.  So
to create a new "person" term you have to write something like

    X = person("Becket, Ralph", 30, male, no)

XXX Should this bit below go in?
Note that not all fields of a constructor need to be named; you
could elect to write something like this:

    :- type my_type
        --->    my_constructor(
                    a_field         :: type1,
                    type2,
                    another_field   :: type3
                ).

So "a_field" and "another_field" can be accessed independently of
all other fields, whereas the second field can only be accessed
by pattern matching against the entire constructor.

XXX Should this bit below go in?
Another thing to be aware of is that not all constructors need to
have the same set of fields.  Consider

    :- type non_empty_list(T)
        --->    last(
                    item    :: T
                ),
        ;       cons(
                    head    :: T,
                    tail    :: list(T)
                ).

Of course, to guarantee that a field access will work in such a
case you have to know that the left hand argument has the right
constructor.

XXX Mention the new ^... notation?

