%------------------------------------------------------------------------------%
% book.tex
% Ralph Becket <rafe@cs.mu.oz.au>
% Mon Jul 15 12:11:53 EST 2002
% vim: ft=tex ff=unix ts=4 sw=4 et wm=8 tw=0
%
%------------------------------------------------------------------------------%



%- Preamble -------------------------------------------------------------------%

\documentclass[a4paper,11pt,notitlepage,onecolumn]{book}
    %
    % [options]
    %   (10|11|12)pt            -- (default 10pt)
    %   (a4|letter)paper        -- (default letterpaper)
    %   fleqn                   -- (default centred) left-align formulae as
    %   leqno                   -- (default right) number formulae on the left
    %   [no]titlepage           -- [do not] start new page after the title
    %   (one|two)column         -- (default onecolumn)
    %   (one|two)side
    %   open(right|any)         -- open chapters on (right|any) pages only
    % {class}
    %   (article|report|book|slides)
    %                           -- consider FoilTeX instead of slides

\usepackage{polytable}

\pagestyle{headings}
    %
    % {style}
    %   (plain|headings|empty)  -- (default plain)
    %                           -- use \thispagestyle{} for new styles

\input{defs}

%- Start of Document ----------------------------------------------------------%

\begin{document}

\setlength{\parindent}{0pt}
\setlength{\parskip}{\baselineskip}
% \setlength{\hoffset}{}        % -- left margin is this + 1in
% \setlength{\voffset}{}        % -- top margin is this + 1in
% \setlength{\textheight}{}
% \setlength{\textwidth}{}
% \setlength{\marginparwidth}{}
    %
    % -- or can use \addtolength{argument}{length}
    % -- or can use \settoheight{argument}{text}
    % -- or can use \settodepth{argument}{text}
    % -- or can use \settowidth{argument}{text}

\title{The Art of Mercury}
\author{Ralph Becket \\ \texttt{\small rafe@cs.mu.oz.au}}
\date{15 October 2001}

% \maketitle

% \begin{abstract}
%
% ...
%
% \end{abstract}

%\tableofcontents

%- Body -----------------------------------------------------------------------%

    % \text(rm|tt|sf|bf|it|sc|sl|up|md|normal){} \emph{}

    % \math(rm|tt|sf|bf|it|sc|sl|up|md|normal){}

    % \tiny \scriptsize \footnotesize \small \normalsize
    % \large \Large \LARGE \huge \Huge
    %                           -- also work as environments

    % ~                         -- small, fixed, nonbreaking space
    % \hspace{size}             -- soft space (may be lost at SOL or EOL)
    % \hspace*{size}            -- hard space
    %                           -- size may be \stretch{factor}
    % \hfill                    -- same as \hspace{\fill}

    % \vspace{size}             -- soft space (may be lost at TOP or BOP)
    % \vspace*{size}            -- hard space
    %                           -- size may be \stretch{factor}
    %                           --  of \smallskip or \bigskip

    % \\                        -- linebreak
    % \\*                       -- linebreak but prohibit page break
    % \newpage

    % \rule[lift]{width}{height}

    % \parbox[(c|t|b)]{width}{text}
    % \begin{minipage}[(c|t|b)]{width} text \end{minipage}
    % \mbox{text}               -- prevents word breaking

    % \begin{(flushleft|flushright|center|quote|verse)}
    % text
    % \end{(flushleft|flushright|center|quote|verse)}

    % \verb@verbatim text@
    % \begin{verbatim}
    % verbatim text
    % \end{verbatim}

    % \begin{tabular}{(l|r|c|p{width}|<bar>|@{colsep})...}
    % datum & datum & ... \
    % datum & datum & ... \
    % \hline
    % datum & datum & ... \
    % \cline{1-2}   & ... \
    % \multicolumn{2}{(l|c|r)}{wide datum} & ... \
    % \end{tabular}

    % \begin{(figure|table)}[[!](h|t|b|p)...]
    % ...
    % \caption{caption text}
    % \end{(figure|table)}

    % \label{marker}            -- set a marker
    % \ref{marker}              -- section containing marker
    % \pageref{marker}          -- page number of marker

    % $ ... $                   -- inline mathematics
    % \[ ... \]                 -- display mathematics
    % \begin{equation}          -- align* suppresses numbering
    % ...
    % \end{equation}
    % \begin{array}{...}        -- as tabular
    % ...
    % \end{array}
    % \begin{eqnarray}          -- as {array}{rcl} but with numbering
    % ...                       -- use \nonumber to suppress numbering of a row
    % \end{eqnarray}
    % \, \; \<spc> \quad \qquad -- math-mode spacing
    % \(over|under)line{...}
    % \(over|under)brace{...}_{...}
    % \wide(tilde|hat)
    % \overrightarrow
    % \frac{top}{bottom}
    % {... \choose ...}         -- adds parentheses
    % {... \atop ...}           -- no parentheses
    % \stackrel{topsym}{linesym}
    % \left<brasym> ... \right<ketsym>
    %                           -- use \right. for no <keysym>
    %                           -- empty lines etc. forbidden in math mode

% \include{}
    %
    % -- \includeonly takes a list of file names and filters any \includes
    %    (can only appear in the preamble.)
    % -- \include takes a single file name, starts a new page
    % -- \input does not start a new page
    % -- omit the .tex suffix from the file names

\newcommand{\polytexopenbrace}%
{\{}
\newcommand{\polytexclosebrace}%
{\}}
\newcommand{\polytexampersand}%
{\&}
%%subst %.*                      \textrm{&}
%%subst --->                     $\longrightarrow$
%%subst -->                      $\rightarrow$
%%subst ->                       $\rightarrow$
%%subst =<                       $\leq$
%%subst >=                       $\geq$
%%subst <=>                      $\Leftrightarrow$
%%subst <=                       $\Leftarrow$
%%subst =>                       $\Rightarrow$
%%subst <<                       $\ll$
%%subst >>                       $\gg$

\setcounter{chapter}{-1}
% vim: ft=tex ff=unix ts=4 sw=4 et tw=76



\chapter{About this book}

Last edited Oct 13 15:28

\textbf{What is this book for?}
\\
A basis for courses teaching or using Mercury.  A tutorial for
experienced programmers wishing to learn Mercury.

\textbf{Who is it aimed at?}
\\
Students who have completed at least one year of a computer science
degree, been exposed to a strongly, statically typed functional programming
language (\eg ML, Haskell, Miranda), and have some reasonable programming
experience.

\textbf{What is this book about?}
\\
This book is a tutorial on programming in Mercury.  The book should
provide the reader with enough information to become a competent Mercury
programmer and knowledge sufficient to understand the Mercury Reference
Manual, the Mercury Library Reference Manual and the Mercury Users' Guide.
The book will describe key features of Mercury in detail, including the type
system, the mode and determinism systems, and programming with
nondeterminism.

\textbf{What is this book not about?}
\\
This book will not teach you how to program in general, nor will it teach
you a great deal of theory.  It will not teach you how type inference works;
it will (probably) not teach you about Herbrand universes; it will not
include an extended treatise on IO in declarative programming languages; it
will not (in the first place) cover black-belt Mercury programming
techniques (e.g. dynamic type casts for non-ground types).

\textbf{Where is the introduction?}
\\
I plan to write the introduction last.  It will include a brief description
of ``what Mercury is all about'' and an explanation of what the book is
trying to do.
\setcounter{chapter}{0}
% vim: ft=tex ff=unix ts=4 sw=4 et tw=76

\chapter{Mercury By Example}

Last edited Jan 28 13:23

This chapter aims to convey through examples a basic feeling for how
Mercury works.  Because this is the first chapter, we may gloss over some
fine detail and allow ourselves a certain latitude in precision, but this
will not worry us as we will correct these deficiencies in later chapters.
The approach taken here is to start by presenting the ``obvious'' solution
to a problem and then introduce features of Mercury that allow for more
elegant or efficient programs --- although we are not necessarily trying to
write the most efficient programs possible at this point! \XXX{Is this last
point even necessary?}



\section{Hello, World!}

It is slightly unfortunate that the ``Hello, World!'' program introduces
no less than three advanced Mercury concepts, but since tradition
dictates that tutorial texts start with ``Hello, World!'' we'll just
have to jump straight in with the knowledge that things will get easier
thereafter.

We'll start by presenting the complete program which we'll assume we've
typed into a file called \textsf{hello.m}:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{module} hello.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{interface}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} io.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} main(io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{implementation}.}}
\nextline
\fromto{col1}{colend}{\textsf{main(IOState\_in, IOState\_out) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.write\_string(``Hello, World!{\ensuremath{\backslash}}n'', IOState\_in, IOState\_out).}}
\nextline
\end{ptabular}

\end{small}
Let's go through this line by line.
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{module} hello.}}
\nextline
\end{ptabular}

\end{small}
Every module must start with a declaration like this giving the name of the
module; the Mercury compiler will expect a module called \textsf{hello} in
a file called \textsf{hello.m}.
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{interface}.}}
\nextline
\end{ptabular}

\end{small}
An \textsf{\textbf{interface}} declaration introduces the part of module describing the
things we are going to export (\ie allow people to see).
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} io.}}
\nextline
\end{ptabular}

\end{small}
This \textsf{\textbf{import\_module}} declaration says that we need to use some of the names
exported by the \textsf{io} module, which is part of the standard Mercury library.
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} main(io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\end{ptabular}

\end{small}
This says that we are going to define a \emph{predicate} called \textsf{main} with
two arguments of type \textsf{io} (which happens to be defined in the \textsf{io}
module), the first of which is a \emph{destructive input} argument, and the
second of which is a \emph{unique output} argument; the \textsf{\textbf{is} \textbf{det}} part
tells us that \textsf{main} is a \emph{deterministic} predicate --- that is,
\textsf{main} always succeeds and will always compute the same output given the
same input (we will see later that in Mercury some predicates can fail and
some can have more than one solution).

Every Mercury program needs to export a predicate called \textsf{main}, which the
compiler takes as the starting point for the Mercury program as a whole.
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{implementation}.}}
\nextline
\end{ptabular}

\end{small}
Everything after an \textsf{\textbf{implementation}} declaration is considered private
implementation detail not visible to other users of the module.
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(IOState\_in, IOState\_out) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.write\_string(``Hello, World!{\ensuremath{\backslash}}n'', IOState\_in, IOState\_out).}}
\nextline
\end{ptabular}

\end{small}
Finally, we have a \emph{clause} defining \textsf{main}.  A clause comprises a
\emph{head} and \emph{body} separated by a \textsf{:{\ensuremath{-}}} symbol.  The \emph{head} of
this clause tells us that this is a definition for \textsf{main} and names its two
arguments \textsf{IOState\_in} and \textsf{IOState\_out}.  The body of the clause, which is executed
when \textsf{main} is called, consists of a single \emph{goal} calling
\textsf{io.write\_string} (\ie the \textsf{write\_string} predicate defined in the \textsf{io}
module) with a message (Mercury interprets the \textsf{{\ensuremath{\backslash}}n} sequence in the string
argument as a literal newline character) and the two \textsf{IOState} arguments.

Program variables in Mercury always start with a capital letter or
underscore, while names of predicates, types, modules and so forth do not.

We can compile and run \textsf{hello.m} as follows (\textsf{\char`\${}} indicates the command line
prompt):
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{\char`\${} mmc {\ensuremath{-}}{\ensuremath{-}}make hello}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/int3s/hello.int3}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/cs/hello.c}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/os/hello.o}}
\nextline
\fromto{col1}{colend}{\textsf{Making hello}}
\nextline
\fromto{col1}{colend}{\textsf{\char`\${} ./hello}}
\nextline
\fromto{col1}{colend}{\textsf{Hello, World!}}
\nextline
\end{ptabular}

\end{small}
Et voila!  (By default, \textsf{mmc {\ensuremath{-}}{\ensuremath{-}}make} will construct a local \textsf{Mercury}
directory, if necessary, to hold intermediate files generated during
compilation.)
\XXX{Check for consistency throughout whether we're using a \textsf{Mercury}
subdirectory or not when compiling.}

At this point the reader is probably wondering about the meaning of the \textsf{io}
type arguments \textsf{IOState\_in} and \textsf{IOState\_out}, and the strange \textsf{di} and \textsf{uo}
\emph{argument modes}.  The short answer is that every predicate that
performs I/O has to have an \textsf{io} type input argument describing
the state of the world at the time the predicate is called and an \textsf{io} type
output argument describing the state of the world after the call.  This is
how Mercury allows programs to communicate with the outside world without
compromising its mathematical integrity.

Because it doesn't make much sense to try reusing an old \textsf{io} state --- once
the print job has finished, you can't get the ink back off the
paper and into the toner cartridge again --- \textsf{io} states are \emph{unique}.
This is where the \textsf{di} and \textsf{uo} argument modes come in: they are just like
the ordinary \textsf{in} and \textsf{out} argument modes we'll meet in the next section,
except that they also specify uniqueness.  The Mercury compiler will not
allow programs to copy unique values or reuse dead ones, which means that
programs that do I/O are guaranteed to behave in the way we expect them to.

So what if we want to do more than one I/O operation?  In this case we have
to give names to each of the intermediate \textsf{io} states:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(IOState\_in, IOState\_out) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.write\_string(``Hello, '', IOState\_in, IOState\_tmp1),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_string(``World!'', IOState\_tmp1, IOState\_tmp2),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.nl(IOState\_tmp2, IOState\_out).}}
\nextline
\end{ptabular}

\end{small}
The first call to \textsf{io.write\_string} takes \textsf{IOState\_in} as an input, destroys it
in the process of writing its string argument, and produces \textsf{IOState\_tmp1} as its
result.  Then the second call to \textsf{io.write\_string} destroys \textsf{IOState\_tmp1}
and produces \textsf{IOState\_tmp2}.  Finally, \textsf{io.nl} (which just writes out a newline),
destroys \textsf{IOState\_tmp2} and returns \textsf{IOState\_out}, which is the result of the call to
\textsf{main}.

Naming all these intermediate states quickly becomes tedious, so Mercury
provides us with syntactic sugar in the form of \emph{state variables}:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.write\_string(``Hello, '', !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_string(``World!'', !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.nl(!IO).}}
\nextline
\end{ptabular}

\end{small}
This code is transformed by the compiler into something equivalent to the
preceding example: each occurrence of the \textsf{!IO} state variable actually
stands for two normal variables, which are given intermediate names in the
``obvious'' way (the full details of the state variable transformation can
be found in the Mercury Reference Manual).  Note that there is no special
significance in the name \textsf{IO}, we merely use \textsf{IO} by convention to stand
for \textsf{io} state arguments.

\subsection*{Points to remember}

\begin{itemize}
\item A module starts with a \textsf{\textbf{module}} declaration and is followed by an
\textsf{\textbf{interface}} section and an \textsf{\textbf{implementation}} section.
\item The interface section declares the things that are exported by the
module.
\item All declarations start with a \textsf{:{\ensuremath{-}}} symbol.
\item Declarations and clauses always end with a full stop.
\item We have to import a module before we can use things exported by that
module.
\item Every Mercury program must export a predicate called \textsf{main}.
\item Clauses, which define predicates, go in the implementation section.
\item Variable names start with a capital letter; names of modules, types,
predicates and so forth start with a lower-case letter or use symbols (\eg
the \textsf{int} module uses \textsf{{\ensuremath{+}}} for addition).
\item Every predicate that performs I/O must have an \textsf{io::di} argument and an
\textsf{io::uo} argument and must be deterministic.
\item We use a state variable to avoid having to name every \textsf{io} state.
\end{itemize}





\newpage





\section{The Fibonacci numbers}

Another great tradition of computer science tutorial texts is to define a
function to calculate numbers in the Fibonacci series.  The Fibonacci series
starts 1 1 2 3 5 8 13 21 34\ldots  Each number after the first two is
computed as the sum of the preceding two numbers.

As before, we'll start by showing a complete program and then look at the
interesting parts in more detail.
\begin{small}

\begin{ptabular}
\column{col8}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col14}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{module} fib.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{interface}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} io.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} main(io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{implementation}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} int.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} fib(int::in, int::out) \textbf{is} \textbf{det}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{fib(N, X) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{col8}{\textsf{(}}
\fromto{col8}{col14}{\textsf{\textbf{if}}}
\fromto{col14}{colend}{\textsf{N {\ensuremath{=}}{\ensuremath{<}} 2}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{col14}{\textsf{\textbf{then}}}
\fromto{col14}{colend}{\textsf{X {\ensuremath{=}} 1}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{col14}{\textsf{\textbf{else}}}
\fromto{col14}{colend}{\textsf{fib(N {\ensuremath{-}} 1, A), fib(N {\ensuremath{-}} 2, B), X {\ensuremath{=}} A {\ensuremath{+}} B}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{fib(17, X),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_string(``fib(17, '', !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_int(X, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_string(``){\ensuremath{\backslash}}n'', !IO).}}
\nextline
\end{ptabular}

\end{small}
Building and running \textsf{fib.m}, we find that\ldots
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{\char`\${} mmc {\ensuremath{-}}{\ensuremath{-}}make fib}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/int3s/fib.int3}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/cs/fib.c}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/os/fib.o}}
\nextline
\fromto{col1}{colend}{\textsf{Making fib}}
\nextline
\fromto{col1}{colend}{\textsf{\char`\${} ./fib}}
\nextline
\fromto{col1}{colend}{\textsf{fib(17, 1597)}}
\nextline
\end{ptabular}

\end{small}

The first thing to note is the \textsf{\textbf{import\_module}} declaration at the start
of the implementation section.  We need to import the \textsf{int} module from the
Mercury standard library because it defines all the operations on integers,
such as addition and comparison.  We import it in the implementation
section rather than the interface section because that's the only place we
refer to names defined in the \textsf{int} module.

Next the declaration
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} fib(int::in, int::out) \textbf{is} \textbf{det}.}}
\nextline
\end{ptabular}

\end{small}
says that we are going to define a predicate \textsf{fib} taking two \textsf{int}
arguments, an input and an output, which always succeeds and always
computes the same output given the same input.
\begin{small}

\begin{ptabular}
\column{col8}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col14}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{fib(N, X) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{col8}{\textsf{(}}
\fromto{col8}{col14}{\textsf{\textbf{if}}}
\fromto{col14}{colend}{\textsf{N {\ensuremath{=}}{\ensuremath{<}} 2}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{col14}{\textsf{\textbf{then}}}
\fromto{col14}{colend}{\textsf{X {\ensuremath{=}} 1}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{col14}{\textsf{\textbf{else}}}
\fromto{col14}{colend}{\textsf{fib(N {\ensuremath{-}} 1, A), fib(N {\ensuremath{-}} 2, B), X {\ensuremath{=}} A {\ensuremath{+}} B}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
The body of the \textsf{fib} definition uses an \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} goal to decide what
to do; the \textsf{\textbf{else}} part is not optional; and the whole thing appears in
parentheses.  The condition \textsf{N {\ensuremath{=}}{\ensuremath{<}} 2} succeeds if \textsf{N} is less than or equal
to 2 and \emph{fails} otherwise (we'll learn more about \textsf{\textbf{semidet}} predicates
like \textsf{{\ensuremath{=}}{\ensuremath{<}}} in later examples).  If \textsf{N {\ensuremath{=}}{\ensuremath{<}} 2} then the
\emph{unification} \textsf{X {\ensuremath{=}} 1} is executed.  Otherwise \textsf{fib} is called twice to
compute the preceding two Fibonacci numbers in \textsf{A} and \textsf{B}, and \textsf{X}
is unified with their sum.

Finally we have
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{fib(17, X),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_string(``fib(17, '', !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_int(X, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_string(``){\ensuremath{\backslash}}n'', !IO).}}
\nextline
\end{ptabular}

\end{small}
which calls \textsf{fib(17, X)}, unifying \textsf{X} with the result of computing the 17th
Fibonacci number, then writes out the answer.

Now, just as \textsf{N {\ensuremath{-}} 1} computes \textsf{N} minus 1 and \textsf{A {\ensuremath{+}} B} computes
the sum of \textsf{A} and \textsf{B}, it is possible to define \textsf{fib} so
that \textsf{fib(N)} computes the \textsf{N}th Fibonacci number:
\begin{small}

\begin{ptabular}
\column{col8}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col14}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{func} fib(int) {\ensuremath{=}} int.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{fib(N) {\ensuremath{=}} X :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{col8}{\textsf{(}}
\fromto{col8}{col14}{\textsf{\textbf{if}}}
\fromto{col14}{colend}{\textsf{N {\ensuremath{=}}{\ensuremath{<}} 2}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{col14}{\textsf{\textbf{then}}}
\fromto{col14}{colend}{\textsf{X {\ensuremath{=}} 1}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{col14}{\textsf{\textbf{else}}}
\fromto{col14}{colend}{\textsf{X {\ensuremath{=}} fib(N {\ensuremath{-}} 1) {\ensuremath{+}} fib(N {\ensuremath{-}} 2)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
The \textsf{\textbf{func}} declaration introduces \textsf{fib} as a \emph{function} with an \textsf{int}
argument computing an \textsf{int} result.  Mercury assumes that the input
arguments to a function have mode \textsf{in} and the result has mode \textsf{out} and
that the function as a whole \textsf{\textbf{is} \textbf{det}}.  Functions calls appear in argument
expressions to unifications, predicate calls and other function calls;
predicate calls, on the other hand, never appear in expressions.

Having redefined \textsf{fib} as a function, we also have to change how it is
called in \textsf{main}:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.write\_string(``fib(17) {\ensuremath{=}} '', !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_int(fib(17), !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.nl(!IO).}}
\nextline
\end{ptabular}

\end{small}

To finish, here is one last refinement we might like to make to our
definition of \textsf{fib}:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{fib(N) {\ensuremath{=}} ( \textbf{if} N {\ensuremath{=}}{\ensuremath{<}} 2 \textbf{then} 1 \textbf{else} fib(N {\ensuremath{-}} 1) {\ensuremath{+}} fib(N {\ensuremath{-}} 2) ).}}
\nextline
\end{ptabular}

\end{small}
By using an \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} \emph{expression} we can move the entire body
into the head of the clause.  Since the clause now has an empty body,
Mercury requires that we omit the \textsf{:{\ensuremath{-}}} part.

It is worth noting that all three of our definitions are computationally
identical and there should be no difference in the code generated by the
Mercury compiler.  Whether to use a predicate or function is largely a
matter of taste; a good rule of thumb is that if a predicate has a single
output argument, and is deterministic, then it is probably better expressed
as a function.

\subsection*{Points to remember}

\begin{itemize}
\item Import modules in the implementation section if they are only referred
to in the implementation section.
\item Non-unique arguments (\ie non-\textsf{io} arguments) should use the \textsf{in}
and \textsf{out} argument modes.
\item Using functions can cut down on the number of intermediate results you
need to name.
\item \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} can be used as a goal and as an expression; it should
appear in parentheses and the \textsf{\textbf{else}} part is mandatory.
\item If a clause of a predicate or a function has an empty body (because
the computation is described in the head), then the \textsf{:{\ensuremath{-}}} must be omitted.
\end{itemize}





\newpage





\section{Simple input}

We can extend our Fibonacci program to read in \textsf{N} rather than have it
hard-coded by changing the definition of \textsf{main}:
\begin{small}

\begin{ptabular}
\column{col8}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} list, string.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.read\_line\_as\_string(Result, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{col8}{\textsf{(}}
\fromto{col8}{colend}{\textsf{\textbf{if}}}
\nextline
\fromto{col1}{col10}{\hspace*{2.7em}}
\fromto{col10}{colend}{\textsf{Result {\ensuremath{=}} ok(String),}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{string.to\_int(string.strip(String), N)}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{then}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{io.format(``fib(\%d) {\ensuremath{=}} \%d{\ensuremath{\backslash}}n'', \char`\[{}i(N), i(fib(N))\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{else}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{io.format(``That's \textbf{not} a number...{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
The \textsf{list} and \textsf{string} standard library modules are imported because we
will need them in the definition of \textsf{main}.

\textsf{main} starts by calling \textsf{io.read\_line\_as\_string}, which reads a whole line
of input up to and including the next newline character.  If all goes well
then \textsf{Result} ends up unified to a value \textsf{ok(String)}, where \textsf{String} is the
string of characters read in and \textsf{ok} is called a \emph{data constructor}.
Other possibilities for \textsf{Result} are \textsf{eof}, indicating the end-of-file has
been reached, and \textsf{error(ErrorCode)}, indicating that something went wrong.

Then an \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} decides what to do.  The \textsf{\textbf{if}} condition succeeds
if \textsf{Result} is an \textsf{ok} value (unifying \textsf{String} with the argument) and
if \\ \textsf{string.to\_int(string.strip(String), N)} succeeds.  The \textsf{string.strip}
function returns its argument minus any leading and trailing whitespace,
including the terminating newline character, while the predicate
\textsf{string.to\_int} succeeds if its first argument is a string of decimal digits
(unifying \textsf{N} with the corresponding number), and fails otherwise.

It's worth taking a slightly closer look at the unification in the \textsf{\textbf{if}} part
of the \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} goal:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{col10}{\hspace*{2.7em}}
\fromto{col10}{colend}{\textsf{Result {\ensuremath{=}} ok(String)}}
\nextline
\end{ptabular}

\end{small}
We know that \textsf{Result} has a value at this point, so this kind of unification
is known as a \emph{deconstruction}: it only succeeds if the value in
\textsf{Result} matches the pattern \textsf{ok(}\emph{something}\textsf{)}, in which case it
unifies \textsf{String} with the \emph{something}.

The \textsf{\textbf{then}} and \textsf{\textbf{else}} arms of the \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} goal call the \textsf{io.format}
predicate, which is rather like C's \textsf{printf} function.  The first argument
is a format string (where \textsf{\%d} indicates a decimal integer, \textsf{\%f} indicates a
floating point value, \textsf{\%s} indicates a string, and \textsf{\%c} indicates a
character)
and the second argument is a list of the corresponding values in \textsf{\char`\[{}}
brackets \textsf{\char`\]{}}, tagged with \textsf{i}, \textsf{f}, \textsf{s} or \textsf{c} for \textsf{int}, \textsf{float}, \textsf{string}
or \textsf{char} values respectively.  Thus in
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{col10}{\hspace*{2.7em}}
\fromto{col10}{colend}{\textsf{io.format(``fib(\%d) {\ensuremath{=}} \%d{\ensuremath{\backslash}}n'', \char`\[{}i(N), i(fib(N))\char`\]{}, !IO)}}
\nextline
\end{ptabular}

\end{small}
the \textsf{int} \textsf{N} is printed instead of the first \textsf{\%d} in the format string
and the \textsf{int} result of \textsf{fib(N)} is printed instead of the second \textsf{\%d}.
If \textsf{N {\ensuremath{=}} 17} we'd expect this goal to output
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{fib(17) {\ensuremath{=}} 1597}}
\nextline
\end{ptabular}

\end{small}
Just as the Mercury compiler doesn't know how to do anything with integers
unless you import the \textsf{int} module, it doesn't know anything about lists
unless you import the \textsf{list} module.  So if you want to use \textsf{io.format} then
you have to import the \textsf{list} and \textsf{string} modules.

Okay, so far so good.  What if we want to input more than one number?
That's easy to arrange:
\begin{small}

\begin{ptabular}
\column{col8}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.read\_line\_as\_string(Result, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{col8}{\textsf{(}}
\fromto{col8}{colend}{\textsf{\textbf{if}}}
\nextline
\fromto{col1}{col10}{\hspace*{2.7em}}
\fromto{col10}{colend}{\textsf{Result {\ensuremath{=}} ok(String),}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{string.to\_int(string.strip(String), N)}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{then}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{io.format(``fib(\%d) {\ensuremath{=}} \%d{\ensuremath{\backslash}}n'', \char`\[{}i(N), i(fib(N))\char`\]{}, !IO),}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{main(!IO)}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{else}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{io.format(``I didn't expect that...{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
Now the \textsf{\textbf{then}} branch calls \textsf{main} recursively to read in another number.
Being a declarative language, recursion is Mercury's only looping
construct.  However, as with any decent declarative language compiler worth
it's salt, tail recursion like this is just as efficient as a \textsf{while} or
\textsf{for} loop in any other language.

Firing up the compiler we get
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{\char`\${} mmc {\ensuremath{-}}{\ensuremath{-}}make fib}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/int3s/fib.int3}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/cs/fib.c}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/os/fib.o}}
\nextline
\fromto{col1}{colend}{\textsf{Making fib}}
\nextline
\fromto{col1}{colend}{\textsf{\char`\${} ./fib}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ 10}}
\nextline
\fromto{col1}{colend}{\textsf{fib(10) {\ensuremath{=}} 55}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ 17}}
\nextline
\fromto{col1}{colend}{\textsf{fib(17) {\ensuremath{=}} 1597}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ 20}}
\nextline
\fromto{col1}{colend}{\textsf{fib(20) {\ensuremath{=}} 6765}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ \char`\^{}D}}
\nextline
\fromto{col1}{colend}{\textsf{I didn't expect that...}}
\nextline
\end{ptabular}

\end{small}
(The \textsf{$|$}s indicate input from the user and don't actually appear on the
screen.  \textsf{\char`\^{}D} indicates the user typing \textsf{Ctrl{\ensuremath{+}}D} to close the input stream;
Windows users should use \textsf{\char`\^{}Z}.)

It would be good to handle the end-of-file condition more gracefully.  The
obvious way to do that is to add another case to the \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}}:
\begin{small}

\begin{ptabular}
\column{col8}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.read\_line\_as\_string(Result, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{col8}{\textsf{(}}
\fromto{col8}{colend}{\textsf{\textbf{if}}}
\nextline
\fromto{col1}{col10}{\hspace*{2.7em}}
\fromto{col10}{colend}{\textsf{Result {\ensuremath{=}} eof}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{then}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{io.format(``bye bye...{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{else} \textbf{if}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{Result {\ensuremath{=}} ok(String),}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{string.to\_int(string.strip(String), N)}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{then}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{io.format(``fib(\%d) {\ensuremath{=}} \%d{\ensuremath{\backslash}}n'', \char`\[{}i(N), i(fib(N))\char`\]{}, !IO),}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{main(!IO)}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{else}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{io.format(``I didn't expect that...{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
Observe the deconstruction test of \textsf{Result} with \textsf{eof} --- the \textsf{eof} data
constructor has no argument list and indeed it is a syntax error to write
\textsf{eof()} as one might in other languages.

Before we leave our \textsf{fib} example, let us introduce Mercury's \emph{switch}
goals.  A switch goal is rather like C's \textsf{switch} statement and consists of
a set of alternatives testing a given variable against different possible
values it might have.  Here is \textsf{main} rewritten to use a switch goal:
\begin{small}

\begin{ptabular}
\column{col12}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col18}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.read\_line\_as\_string(Result, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{(}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} eof,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.format(``bye bye...{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{;}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} ok(String),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col12}{\textsf{(}}
\fromto{col12}{col18}{\textsf{\textbf{if}}}
\fromto{col18}{colend}{\textsf{string.to\_int(string.strip(String), N)}}
\nextline
\fromto{col1}{col12}{\textsf{}}
\fromto{col12}{col18}{\textsf{\textbf{then}}}
\fromto{col18}{colend}{\textsf{io.format(``fib(\%d) {\ensuremath{=}} \%d{\ensuremath{\backslash}}n'', \char`\[{}i(N), i(fib(N))\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col12}{\textsf{}}
\fromto{col12}{col18}{\textsf{\textbf{else}}}
\fromto{col18}{colend}{\textsf{io.format(``that isn't a number{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{main(!IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{;}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} error(ErrorCode),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.format(``\%s{\ensuremath{\backslash}}n'', \char`\[{}s(io.error\_message(ErrorCode))\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
A sequence of goals separated by semicolons is called a \emph{disjunction}
(the semicolon is usually pronounced ``or'').  If each \emph{disjunct}
deconstructs a particular variable against a set of mutually exclusive
possibilities, then it is called a switch.  In general it is good style to
use a switch rather than a sequence of \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} goals since then, in
most cases, the Mercury compiler will tell you if you've forgotten a
possibility or counted the same possibility twice.

\subsection*{Points to remember}

\begin{itemize}
\item Some types (such as the result type of \textsf{io.read\_line\_as\_string}) use
different data constructors for different values.  These values can be
tested using deconstruction unifications.
\item A data constructor with no arguments, such as \textsf{eof}, is not followed
by an argument list.
\item \textsf{io.format} is Mercury's version of C's \textsf{printf}.  To use it you must
import \textsf{list} and \textsf{string} as well as the \textsf{io} module.
\item You should omit the parentheses around an \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} that
immediately follows the \textsf{\textbf{else}} part of another \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}}.
\item A disjunction is a sequence of goals separated by semicolons.
\item A switch is a disjunction where each disjunct tests a particular
variable against a different possibility.  Where applicable, switches are
generally preferable to \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}}s.
\end{itemize}





\newpage





\section{\textsf{rot13}}

Let's move on to a different example.  This time we are going to implement
the \textsf{rot13} ``encryption'' algorithm, which works by rotating the Roman
alphabet by 13 places --- in other words, \textsf{abcdefghijklmnopqrstuvwxyz} in
the input becomes \textsf{nopqrstuvwxyzabcdefghijklm} in the output.  Decryption is
simple: just use \textsf{rot13} a second time!  While \textsf{rot13} has the cryptographic
strength of damp tissue paper, it is sometimes useful for obscuring
information in an e-mail that the recipient may not yet wish to know,
such as who won the Grand Final the day before.

Here's a first cut at a solution:
\begin{small}

\begin{ptabular}
\column{col40}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col16}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col28}{@{\ }l@{}}
\column{col19}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{module} rot13.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{interface}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} io.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} main(io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{implementation}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} char, list, string.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.read\_char(Result, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{(}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} ok(Char),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.write\_char(rot13(Char), !IO),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{main(!IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{;}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} eof}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{;}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} error(ErrorCode),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.format(``\%s{\ensuremath{\backslash}}n'', \char`\[{}s(io.error\_message(ErrorCode))\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{func} rot13(char) {\ensuremath{=}} char.}}
\nextline
\nextline
\fromto{col1}{col16}{\textsf{rot13(Char) {\ensuremath{=}}}}
\fromto{col16}{col19}{\textsf{(}}
\fromto{col19}{col28}{\textsf{\textbf{if}}}
\fromto{col28}{col40}{\textsf{Char {\ensuremath{=}} 'a'}}
\fromto{col40}{colend}{\textsf{\textbf{then} 'n'}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{col28}{\textsf{\textbf{else} \textbf{if}}}
\fromto{col28}{col40}{\textsf{Char {\ensuremath{=}} 'b'}}
\fromto{col40}{colend}{\textsf{\textbf{then} 'o'}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{colend}{\textsf{...}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{col28}{\textsf{\textbf{else} \textbf{if}}}
\fromto{col28}{col40}{\textsf{Char {\ensuremath{=}} 'z'}}
\fromto{col40}{colend}{\textsf{\textbf{then} 'm'}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{col28}{\textsf{\textbf{else} \textbf{if}}}
\fromto{col28}{col40}{\textsf{Char {\ensuremath{=}} 'A'}}
\fromto{col40}{colend}{\textsf{\textbf{then} 'N'}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{col28}{\textsf{\textbf{else} \textbf{if}}}
\fromto{col28}{col40}{\textsf{Char {\ensuremath{=}} 'B'}}
\fromto{col40}{colend}{\textsf{\textbf{then} 'O'}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{colend}{\textsf{...}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{col28}{\textsf{\textbf{else} \textbf{if}}}
\fromto{col28}{col40}{\textsf{Char {\ensuremath{=}} 'Z'}}
\fromto{col40}{colend}{\textsf{\textbf{then} 'M'}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{col28}{\textsf{\textbf{else}}}
\fromto{col28}{colend}{\textsf{Char}}
\nextline
\fromto{col1}{col16}{\textsf{}}
\fromto{col16}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
While this plainly works:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{\char`\${} mmc {\ensuremath{-}}{\ensuremath{-}}make rot13}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/int3s/rot13.int3}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/cs/rot13.c}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/os/rot13.o}}
\nextline
\fromto{col1}{colend}{\textsf{Making rot13}}
\nextline
\fromto{col1}{colend}{\textsf{\char`\${} ./rot13}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ Port Adelaide beat the Brisbane Lions 113 to 73 in the Grand Final.}}
\nextline
\fromto{col1}{colend}{\textsf{Cbeg Nqrynvqr orng gur Oevfonar Yvbaf 113 gb 73 va gur Tenaq Svany.}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ Cbeg Nqrynvqr orng gur Oevfonar Yvbaf 113 gb 73 va gur Tenaq Svany.}}
\nextline
\fromto{col1}{colend}{\textsf{Port Adelaide beat the Brisbane Lions 113 to 73 in the Grand Final.}}
\nextline
\end{ptabular}

\end{small}
it's hardly going to win prizes for elegance or efficiency.  A more
experienced Mercury programmer might code \textsf{rot13} like this:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col14}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{func} rot13(char) {\ensuremath{=}} char.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{rot13(CharIn) {\ensuremath{=}} ( \textbf{if} rot13b(CharIn, CharOut) \textbf{then} CharOut \textbf{else} CharIn ).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} rot13b(char::in, char::out) \textbf{is} \textbf{semidet}.}}
\nextline
\nextline
\fromto{col1}{col14}{\textsf{rot13b('a',}}
\fromto{col14}{colend}{\textsf{'n').}}
\nextline
\fromto{col1}{col14}{\textsf{rot13b('b',}}
\fromto{col14}{colend}{\textsf{'o').}}
\nextline
\fromto{col1}{colend}{\textsf{...}}
\nextline
\fromto{col1}{col14}{\textsf{rot13b('z',}}
\fromto{col14}{colend}{\textsf{'m').}}
\nextline
\fromto{col1}{col14}{\textsf{rot13b('A',}}
\fromto{col14}{colend}{\textsf{'N').}}
\nextline
\fromto{col1}{col14}{\textsf{rot13b('B',}}
\fromto{col14}{colend}{\textsf{'O').}}
\nextline
\fromto{col1}{colend}{\textsf{...}}
\nextline
\fromto{col1}{col14}{\textsf{rot13b('Z',}}
\fromto{col14}{colend}{\textsf{'M').}}
\nextline
\end{ptabular}

\end{small}
There are three new things here: the \textsf{\textbf{semidet}} \emph{determinism category},
clauses with the arguments already ``filled in'', and using more than one
clause to define a predicate.

First off, the \textsf{\textbf{semidet}} determinism category means that \textsf{rot13b} will, for
any given input, either fail or compute a single answer.  Looking at the
code we might guess (correctly) that \textsf{rot13b('z', X)} should succeed
unifying \textsf{X {\ensuremath{=}} 'm'} (and never anything else), while \textsf{rot13b('7', X)}
would fail.

Secondly, a clause like
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{rot13b('a', 'n').}}
\nextline
\end{ptabular}

\end{small}
is just syntactic sugar for
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{rot13b(V$_{1}$, V$_{2}$) :{\ensuremath{-}} V$_{1}$ {\ensuremath{=}} 'a', V$_{2}$ {\ensuremath{=}} 'n'.}}
\nextline
\end{ptabular}

\end{small}
Since we know from the \textsf{\textbf{pred}} declaration for \textsf{rot13b} that \textsf{V$_{1}$} is an
input and \textsf{V$_{2}$} an output, the unification \textsf{V$_{1}$ {\ensuremath{=}} 'a'} must be a
deconstruction test and, if that succeeds, then the \emph{construction}
unification \textsf{V$_{2}$ {\ensuremath{=}} 'n'} is carried out (a construction unification always
succeeds because the ``destination'' variable, \textsf{V$_{2}$} in this case, does not
have a value before this point).

Finally, a sequence of clauses is syntactic sugar for a single clause whose
body is a disjunction.  Hence our code is transformed by the compiler
into this:
\begin{small}

\begin{ptabular}
\column{col20}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col23}{@{\ }l@{}}
\column{col34}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{col20}{\textsf{rot13b(V$_{1}$, V$_{2}$) :{\ensuremath{-}}}}
\fromto{col20}{col23}{\textsf{(}}
\fromto{col23}{col34}{\textsf{V$_{1}$ {\ensuremath{=}} 'a',}}
\fromto{col34}{colend}{\textsf{V$_{2}$ {\ensuremath{=}} 'n'}}
\nextline
\fromto{col1}{col20}{\textsf{}}
\fromto{col20}{col23}{\textsf{;}}
\fromto{col23}{col34}{\textsf{V$_{1}$ {\ensuremath{=}} 'b',}}
\fromto{col34}{colend}{\textsf{V$_{2}$ {\ensuremath{=}} 'o'}}
\nextline
\fromto{col1}{col23}{\textsf{}}
\fromto{col23}{colend}{\textsf{...}}
\nextline
\fromto{col1}{col20}{\textsf{}}
\fromto{col20}{col23}{\textsf{;}}
\fromto{col23}{col34}{\textsf{V$_{1}$ {\ensuremath{=}} 'z',}}
\fromto{col34}{colend}{\textsf{V$_{2}$ {\ensuremath{=}} 'm'}}
\nextline
\fromto{col1}{col20}{\textsf{}}
\fromto{col20}{col23}{\textsf{;}}
\fromto{col23}{col34}{\textsf{V$_{1}$ {\ensuremath{=}} 'A',}}
\fromto{col34}{colend}{\textsf{V$_{2}$ {\ensuremath{=}} 'N'}}
\nextline
\fromto{col1}{col20}{\textsf{}}
\fromto{col20}{col23}{\textsf{;}}
\fromto{col23}{col34}{\textsf{V$_{1}$ {\ensuremath{=}} 'B',}}
\fromto{col34}{colend}{\textsf{V$_{2}$ {\ensuremath{=}} 'O'}}
\nextline
\fromto{col1}{col23}{\textsf{}}
\fromto{col23}{colend}{\textsf{...}}
\nextline
\fromto{col1}{col20}{\textsf{}}
\fromto{col20}{col23}{\textsf{;}}
\fromto{col23}{col34}{\textsf{V$_{1}$ {\ensuremath{=}} 'Z',}}
\fromto{col34}{colend}{\textsf{V$_{2}$ {\ensuremath{=}} 'M' ).}}
\nextline
\end{ptabular}

\end{small}
The astute reader will immediately identify this as a switch on \textsf{V$_{1}$} because
each disjunct tests the input \textsf{V$_{1}$} for a different possible value.  One of
the good things about switches is that the Mercury compiler will generate
very efficient code for them, using a lookup-table or hash-table perhaps,
which will certainly out-perform the long chain of \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}}s in our
first attempt.

(As an aside, the \textsf{\textbf{is} \textbf{semidet}} determinism declaration for \textsf{rot13b} tells
the Mercury compiler that this predicate is expected to fail in some cases,
so it will not warn us about missing possible values for the first argument.
In the \textsf{fib} program the switch had to be exhaustive, so it could not fail,
because \textsf{main} was declared to be \textsf{\textbf{det}}.  Had we missed a possible case out
of that switch, the compiler would have reported the missing case as an
error.)

Note that if we felt so inclined, we could make \textsf{rot13b} deterministic by
including the translation of every possible character!  Of course, there are
many ways of coding \textsf{rot13} and while our implementation may not be the most
concise, it is quite efficient and very easy to understand.  Either way, our
aim here was to look more closely at the concept of semideterminism and
introduce the technique of making code more readable by using multiple
clauses to define a predicate or function.

\subsection*{Points to remember}

\begin{itemize}
\item Literal character values in Mercury are normally enclosed in single
quotes.  Some characters which the Mercury parser would normally expect to
see used as infix function symbols, such as \textsf{{\ensuremath{+}}} and \textsf{{\ensuremath{*}}}, also need to be
enclosed in parentheses: \textsf{('{\ensuremath{+}}')} and \textsf{('{\ensuremath{*}}')}.  Full details of how special
characters should be written can be found in the the Mercury Reference
Manual.
\item The \textsf{\textbf{semidet}} determinism category means that a predicate can have
at most one \emph{solution} for a given set of inputs (if it has no solution
for the given inputs then it fails).
\item Semideterministic predicates therefore often appear in the conditions
of \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} goals.
\item ``Filling in'' the arguments of a clause is just shorthand for
omitting the equivalent unification goals.
\item The compiler will view a predicate or function definition comprising
several clauses as a disjunction.  Multiple clauses are often easier to read
than the equivalent disjunction.
\end{itemize}





\newpage




\section{Cryptarithms}

In this example we try to demonstrate a little of what differentiates
Mercury from conventional programming languages.  A cryptarithm is an
equation (usually just an addition) where the digits of each number have
been replaced by letters, \textsf{DOG {\ensuremath{+}} ANT {\ensuremath{=}} CAT} for example; a solution is a
mapping from letters to digits that satisfies the equation.  Leading letters
cannot stand for zero and each letter must stand for a distinct digit.
Here's a Mercury program to solve this particular cryptarithm:
\begin{small}

\begin{ptabular}
\column{col7}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col14}{@{\ }l@{}}
\column{col16}{@{\ }l@{}}
\column{col52}{@{\ }l@{}}
\column{col26}{@{\ }l@{}}
\column{col17}{@{\ }l@{}}
\column{col35}{@{\ }l@{}}
\column{col36}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col48}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{module} crypt.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{interface}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} io.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} main(io::di, io::uo) \textbf{is} \textbf{cc\_multi}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{implementation}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} int, list, string.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.format(``DOG {\ensuremath{+}} ANT {\ensuremath{=}} CAT{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{( \textbf{if}}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{col48}{\textsf{Ds$_{0}$ {\ensuremath{=}} \char`\[{}0, 1, 2, 3, 4, 5, 6, 7, 8, 9\char`\]{},}}
\fromto{col48}{col52}{\textsf{C$_{0}$}}
\fromto{col52}{colend}{\textsf{{\ensuremath{=}} 0,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col16}{\textsf{pick(}}
\fromto{col16}{colend}{\textsf{Ds$_{0}$, G, Ds$_{1}$),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col16}{\textsf{pick(}}
\fromto{col16}{colend}{\textsf{Ds$_{1}$, T, Ds$_{2}$),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col48}{\textsf{T {\ensuremath{=}} (G {\ensuremath{+}} T {\ensuremath{+}} C$_{0}$) mod 10,}}
\fromto{col48}{col52}{\textsf{C$_{1}$}}
\fromto{col52}{colend}{\textsf{{\ensuremath{=}} (G {\ensuremath{+}} T {\ensuremath{+}} C$_{0}$) / 10,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col16}{\textsf{pick(}}
\fromto{col16}{colend}{\textsf{Ds$_{2}$, O, Ds$_{3}$),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col16}{\textsf{pick(}}
\fromto{col16}{colend}{\textsf{Ds$_{3}$, N, Ds$_{4}$),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col35}{\textsf{A {\ensuremath{=}} (O {\ensuremath{+}} N {\ensuremath{+}} C$_{1}$) mod 10,}}
\fromto{col35}{col48}{\textsf{A {\ensuremath{\backslash}}{\ensuremath{=}} 0,}}
\fromto{col48}{col52}{\textsf{C$_{2}$}}
\fromto{col52}{colend}{\textsf{{\ensuremath{=}} (O {\ensuremath{+}} N {\ensuremath{+}} C$_{1}$) / 10,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col16}{\textsf{pick(}}
\fromto{col16}{colend}{\textsf{Ds$_{4}$, D, Ds$_{5}$),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col16}{\textsf{pick(}}
\fromto{col16}{colend}{\textsf{Ds$_{5}$, A, Ds$_{6}$),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col35}{\textsf{C {\ensuremath{=}} (D {\ensuremath{+}} A {\ensuremath{+}} C$_{2}$) mod 10,}}
\fromto{col35}{col48}{\textsf{D {\ensuremath{\backslash}}{\ensuremath{=}} 0,}}
\fromto{col48}{col52}{\textsf{0}}
\fromto{col52}{colend}{\textsf{{\ensuremath{=}} (D {\ensuremath{+}} A {\ensuremath{+}} C$_{2}$) / 10,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col16}{\textsf{pick(}}
\fromto{col16}{colend}{\textsf{Ds$_{6}$, C, \_)}}
\nextline
\fromto{col1}{col7}{\hspace*{1.8em}}
\fromto{col7}{colend}{\textsf{\textbf{then}}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col14}{\textsf{DOG}}
\fromto{col14}{col17}{\textsf{{\ensuremath{=}}}}
\fromto{col17}{col26}{\textsf{100 {\ensuremath{*}} D}}
\fromto{col26}{col36}{\textsf{{\ensuremath{+}} 10 {\ensuremath{*}} O}}
\fromto{col36}{colend}{\textsf{{\ensuremath{+}} G,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col14}{\textsf{ANT}}
\fromto{col14}{col17}{\textsf{{\ensuremath{=}}}}
\fromto{col17}{col26}{\textsf{100 {\ensuremath{*}} A}}
\fromto{col26}{col36}{\textsf{{\ensuremath{+}} 10 {\ensuremath{*}} N}}
\fromto{col36}{colend}{\textsf{{\ensuremath{+}} T,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col14}{\textsf{CAT}}
\fromto{col14}{col17}{\textsf{{\ensuremath{=}}}}
\fromto{col17}{col26}{\textsf{100 {\ensuremath{*}} C}}
\fromto{col26}{col36}{\textsf{{\ensuremath{+}} 10 {\ensuremath{*}} A}}
\fromto{col36}{colend}{\textsf{{\ensuremath{+}} T,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.format(``\%d {\ensuremath{+}} \%d {\ensuremath{=}} \%d{\ensuremath{\backslash}}n'', \char`\[{}i(DOG), i(ANT), i(CAT)\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col7}{\textsf{}}
\fromto{col7}{colend}{\textsf{\textbf{else}}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.format(``has no solutions{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\nextline
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{pred}}}
\fromto{col10}{colend}{\textsf{pick(list(int)::in, int::out, list(int)::out) \textbf{is} \textbf{nondet}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{pick(\char`\[{}X $|$ Xs\char`\]{}, X, Xs).}}
\nextline
\fromto{col1}{colend}{\textsf{pick(\char`\[{}X $|$ Xs\char`\]{}, Y, \char`\[{}X $|$ Zs\char`\]{}) :{\ensuremath{-}} pick(Xs, Y, Zs).}}
\nextline
\end{ptabular}

\end{small}
At this early stage it would be wrong to try to explain exactly \emph{how}
this program works.  Instead, we will describe \emph{what} it does and offer
hints as to how it does it, but leave the technical explanation to later
chapters.

The interesting part of this program is the condition of the \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}}
goal.  The trick to understanding this code fragment is to consider it as a
set of constraints on a solution rather than as a series of computations.
(Concentrating on the ``what'' rather than the ``how'' is a hallmark of
declarative programming.)

\textsf{Ds$_{0}$} is the list of digits from 0 to 9, \textsf{Ds$_{1}$} is \textsf{Ds$_{0}$} with the digit for
\textsf{G} removed, \textsf{Ds$_{2}$} is \textsf{Ds$_{1}$} with the digit for \textsf{T} removed, \textsf{Ds$_{3}$} is \textsf{Ds$_{2}$}
with the digit for \textsf{O} removed, and so forth.  In this way we ensure that
each of \textsf{D}, \textsf{O}, \textsf{G}, \textsf{A}, \textsf{N}, \textsf{T} and \textsf{C} are different digits.

The digits for each letter are selected nondeterministically using the
\textsf{pick} predicate.  The goal \textsf{pick(Ds$_{0}$, G, Ds$_{1}$)}, for instance, picks a digit
for \textsf{G} from \textsf{Ds$_{0}$} and leaves the remainder in \textsf{Ds$_{1}$}.  Since \textsf{Ds$_{0}$} contains
ten members, there are ten possible solutions for \textsf{G}.

\textsf{C$_{1}$} is the carry left over from the units column, \textsf{C$_{2}$} is the carry left
over from the tens column, and we introduce \textsf{C$_{0}$} as a ``carry in'' of
zero just to keep the structure of the program regular.

We verify that the units column works out with the goal
\textsf{T {\ensuremath{=}} (G {\ensuremath{+}} T {\ensuremath{+}} C$_{0}$) mod 10}.  Similarly the goal
\textsf{A {\ensuremath{=}} (O {\ensuremath{+}} N {\ensuremath{+}} C$_{1}$) mod 10} verifies the tens column is consistent and
\textsf{C {\ensuremath{=}} (D {\ensuremath{+}} A {\ensuremath{+}} C$_{2}$) mod 10} verifies the hundreds column works.

The goals \textsf{A {\ensuremath{\backslash}}{\ensuremath{=}} 0} and \textsf{D {\ensuremath{\backslash}}{\ensuremath{=}} 0} ensure that we don't have any zeroes in the
hundreds column, while \textsf{0 {\ensuremath{=}} (D {\ensuremath{+}} A {\ensuremath{+}} C$_{2}$) / 10} ensures that there is no
carry left over from the sum as a whole (\textsf{/}, the division function on
\textsf{int}s, truncates the result towards zero).

Informally, Mercury tries to find a solution to the condition goal as a
whole by considering each subgoal in turn.  The \textsf{pick} goals are slightly
special because they can have more than one possible solution; such goals are
referred to as \emph{choice points}.  When the
Mercury program executes a \textsf{pick} goal, it considers each possibility in
turn until it finds one that works.  It does this by \emph{backtracking}
whenever it encounters a goal that fails.  Backtracking unwinds the
computation to the last choice point (\ie the most recent \textsf{pick} goal),
undoing any unifications that have since occurred, and tries another
alternative.  If all of the possibilities for a given \textsf{pick} goal lead to
failure, then backtracking continues to the preceding \textsf{pick} goal, and so
on.

Eventually either a set of solutions to the \textsf{pick} goals will be found that
is consistent with the other constraints or, if no such set exists, then
this part of the program will fail.

At this point we can explain the \textsf{\textbf{cc\_multi}} determinism category for \textsf{main},
which is different to \textsf{\textbf{det}} which we've used in all the preceding examples.
\textsf{\textbf{cc\_multi}} stands for \emph{committed choice multideterministic}, which means
that although this predicate may have multiple possible answers (there may
be multiple solutions to \textsf{main}'s \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} condition) we will only be
getting one of them!  This extra constraint is necessary to allow a
predicate with more than one possible solution to perform I/O; since we're
not allowed to backtrack over predicates that do I/O, we have to state that
we're content for \textsf{main} to stick to the first solution it sees, whichever
one that happens to be.

As with \textsf{main}, we won't explain here \emph{how} \textsf{pick} works suffice to
give plain English descriptions of the clauses:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{pick(\char`\[{}X $|$ Xs\char`\]{}, X, Xs).}}
\nextline
\end{ptabular}

\end{small}
This clause says that given a list whose \emph{head} is the item \textsf{X} and
whose \emph{tail} is the list of items \textsf{Xs}, we can remove \textsf{X} from the
input leaving \textsf{Xs} as the remainder.
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{pick(\char`\[{}X $|$ Xs\char`\]{}, Y, \char`\[{}X $|$ Zs\char`\]{}) :{\ensuremath{-}} pick(Xs, Y, Zs).}}
\nextline
\end{ptabular}

\end{small}
This clause says that given a list with head \textsf{X} and tail \textsf{Xs}, we remove an
item \textsf{Y} from \textsf{Xs} leaving remainder \textsf{Zs} (via the recursive call to
\textsf{pick}), and the remainder of the original input then is the list whose head
is \textsf{X} and whose tail is \textsf{Zs}.

Don't worry if much of this seems confusing: once some facility with
thinking declaratively (\ie ``what'' rather than ``how'') is acquired, one
will be able to look at predicates like \textsf{pick} and complicated goals like
the condition of \textsf{main}'s \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} and immediately understand what is
meant.  The thing to carry away from this example is the ease with which
Mercury allows us to describe a solution to a complex search problem.  We
have done very little more than write a logical specification of the problem
using Mercury syntax, all the tedious operational details are handled for us
by the compiler!  Elegance of this sort is one of the key things that makes
Mercury such an attractive programming language.

Anyway, after all that hard work, let's just prove that all this magic
actually works:
\begin{small}

\begin{ptabular}
\column{col13}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col6}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{\char`\${} mmc {\ensuremath{-}}{\ensuremath{-}}make crypt}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/int3s/crypt.int3}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/cs/crypt.c}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/os/crypt.o}}
\nextline
\fromto{col1}{colend}{\textsf{Making crypt}}
\nextline
\fromto{col1}{colend}{\textsf{\char`\${} ./crypt}}
\nextline
\fromto{col1}{col6}{\textsf{DOG}}
\fromto{col6}{col13}{\textsf{{\ensuremath{+}} ANT}}
\fromto{col13}{colend}{\textsf{{\ensuremath{=}} CAT}}
\nextline
\fromto{col1}{col6}{\textsf{420}}
\fromto{col6}{col13}{\textsf{{\ensuremath{+}} 531}}
\fromto{col13}{colend}{\textsf{{\ensuremath{=}} 951}}
\nextline
\end{ptabular}

\end{small}
Success!

\subsection*{Points to remember}

\begin{itemize}
\item Nondeterministic predicates such as \textsf{pick} can have multiple solutions
for a given set of inputs.  Mercury handles this by backtracking to the most
recent choice point when a later goal fails.
\item As far as possible, try to think declaratively rather than
operationally: focus on what it is that is being computed rather than how
the computation should proceed.  Leave as much of that sort of detail to the
compiler as you can.
\item Unification goals are quite versatile: they can denote constructions,
deconstructions, and equality tests.
\end{itemize}
\setcounter{chapter}{1}
% vim: ft=tex ff=unix ts=4 sw=4 et tw=76



\chapter{The Mercury type system}

Last edited Jan 18 17:56

In this chapter we describe the primitive (\ie built-in) Mercury types, and
how to define and use new types.  The style of this chapter is a little dry,
so we advise the reader to skim through it the first time around, and then
dip back into it for reference as occasion demands.

Mercury uses an expressive, statically checked type system similar to
that of ML and Haskell.  The type system is expressive in the sense that the
compiler can always infer the type held in a particular variable; apart from
one exception, which is described below, type casts of the kind found in
Java and C programs are unnecessary.  Static type checking means that any
possible type violation in a program is detected at compile-time rather than
at run-time.  Many common programming errors are, therefore, simply
inexpressible in Mercury.  A handy secondary benefit of this approach to
typing is that the compiler can generate highly optimized code.

Mercury also supports dynamic typing and type reflection for the rare cases
where such things are necessary.  Dynamic typing is supported by a universal
type that can conceal values of any type at all; however, extracting a
concealed value does require a checked run-time type cast operation.  Type
reflection allows a program to examine the structure of values and their
types.  By way of example, a generic function to compute hash codes for
values of any type depends upon type reflection.

\subsection*{Important!}

Mercury is a purely declarative language.  This means that values are
immutable: there is no destructive assignment.  Every computation constructs
a new value for each output.  The compiler may well generate code that uses
destructive assignment (\eg for efficient array updates), but such things
are not directly available to the Mercury programmer.



\section{The primitive types: \textsf{int}, \textsf{float}, \textsf{string}, and \textsf{char}}

\Note The underlying representation of the primitive types
depends upon the compiler target (C, Java, .Net etc.)  For the C targets
\textsf{int} corresponds to \textsf{int}, \textsf{float} to \textsf{double}, \textsf{char} to \textsf{char}
and \textsf{string} to \textsf{char {\ensuremath{*}}}; number ranges, representations, arithmetic
overflow handling and so forth are dictated by the target machine.

\subsection*{\textsf{int}}

Fixed precision integers are represented by the \textsf{int} type.  Syntactically,
an \textsf{int} is a sequence of digits, optionally preceded by a minus sign (there
is no unary plus).  The sequence of digits may be decimal, hexadecimal (if
preceded by \textsf{0x}), octal (if preceded by \textsf{0o}), or binary (if preceded by
\textsf{0b}).

Examples: decimal \textsf{{\ensuremath{-}}123}, \textsf{0}, \textsf{42}; hexadecimal \textsf{{\ensuremath{-}}0x7B}, \textsf{0x0}, \textsf{0x2A};
octal \textsf{{\ensuremath{-}}0o173}, \textsf{0o0}, \textsf{0o52}; binary \textsf{{\ensuremath{-}}0b1111011}, \textsf{0b0}, \textsf{0b101010}.

The sequence \textsf{0'x} denotes the character code for the character \textsf{x}.  For
example, on an ASCII system \textsf{0'a}, \textsf{0'b}, and \textsf{0'c} denote 97, 98, and 99
respectively.

The \textsf{int} standard library module must be imported to use any of the
primitive \textsf{int} operations.

\subsection*{\textsf{float}}

Floating point numbers are represented by the \textsf{float} type, which
corresponds to the C \textsf{double} type.  Syntactically, a \textsf{float} is a decimal
floating point number (the decimal point is required), optionally preceded
by a minus sign, optionally followed by an integer exponent.

These are all equivalent: \textsf{1.414}, \textsf{1414e{\ensuremath{-}}3}, \textsf{.1414e1}, \textsf{0.01414e2};
either \textsf{e} or \textsf{E} is acceptable as the exponent separator.

The \textsf{float} standard library module must be imported to use any of the
primitive \textsf{float} operations.  Constants such as \textsf{pi} and \textsf{e} and more
complex floating point operations, such as the trigonometric functions, are
defined in the \textsf{math} standard library module.

\subsection*{\textsf{string}}

A string constant is a sequence of characters enclosed in double
quotes.

Examples: \textsf{`` ''}, \textsf{``Hello, World!{\ensuremath{\backslash}}n''}, \textsf{``{\ensuremath{\backslash}}``Lawks!{\ensuremath{\backslash}}'' I declared.''}.

Certain characters have special syntax referred known as \emph{character
escapes}:

\begin{tabular}{llll}
\textsf{{\ensuremath{\backslash}}"} & double quote &
\textsf{{\ensuremath{\backslash}}{\ensuremath{\backslash}}} & backslash \\
\textsf{{\ensuremath{\backslash}}'} & single quote &
\textsf{{\ensuremath{\backslash}}a} & alert (``beep'') \\
\textsf{{\ensuremath{\backslash}}b} & backspace &
\textsf{{\ensuremath{\backslash}}r} & carriage return \\
\textsf{{\ensuremath{\backslash}}f} & form-feed &
\textsf{{\ensuremath{\backslash}}t} & tab \\
\textsf{{\ensuremath{\backslash}}n} & newline &
\textsf{{\ensuremath{\backslash}}v} & vertical tab
\end{tabular}


Characters can also be specified by character code using the sequence
\textsf{{\ensuremath{\backslash}}xhh{\ensuremath{\backslash}}}, where \textsf{hh} is a hexadecimal number, or \textsf{{\ensuremath{\backslash}}ooo{\ensuremath{\backslash}}}, where \textsf{ooo} is an
octal number.  the ASCII character \textsf{A}, for example, can also be written
as \textsf{{\ensuremath{\backslash}}x41{\ensuremath{\backslash}}} or \textsf{{\ensuremath{\backslash}}101{\ensuremath{\backslash}}}.

\Note For arcane reasons, it is a Very Bad Idea to include the \textsf{NUL}
character, \textsf{{\ensuremath{\backslash}}x00{\ensuremath{\backslash}}}, in strings.

A backslash at the end of a line is ignored in string constants.  Thus
\\\textsf{``abc{\ensuremath{\backslash}}}\\\textsf{def"}\\ is equivalent to just \textsf{``abcdef''}.  Otherwise, literal
newlines may appear in a string constant:
\\\textsf{``pqr}\\\textsf{xyz''}\\ is equivalent to \textsf{``pqr{\ensuremath{\backslash}}nxyz''}.

The \textsf{string} standard library module must be imported to use any of the
primitive \textsf{string} operations.  In particular it defines \textsf{{\ensuremath{+}}{\ensuremath{+}}}, the string
concatenatation function --- for example, \textsf{``foo'' {\ensuremath{+}}{\ensuremath{+}} ``bar'' {\ensuremath{=}} ``foobar''}.

\subsection*{\textsf{char}}

Character constants are represented using the \textsf{char} type and,
syntactically, are single characters (or character escapes or character
codes as described above) enclosed in single quotes.  Characters that could
be interpreted as infix operators, such as \textsf{{\ensuremath{+}}} and \textsf{{\ensuremath{*}}}, should be further
enclosed in parentheses.

Examples: \textsf{'A'}, \textsf{'{\ensuremath{\backslash}}x41{\ensuremath{\backslash}}'}, \textsf{'{\ensuremath{\backslash}}101{\ensuremath{\backslash}}'}, \textsf{'{\ensuremath{\backslash}}''}, \textsf{'{\ensuremath{\backslash}}n'}, \textsf{('{\ensuremath{+}}')}, \textsf{('{\ensuremath{*}}')}.

\XXX{Are we ASCII specific?}

The \textsf{char} standard library module must be imported to use any of the
primitive operations on \textsf{char}s.



\section{Tuples}

A tuple is a fixed size vector of values.  Syntactically, a tuple
\emph{type} is a comma separated sequence of type names enclosed in braces,
whereas a tuple \emph{value} is a comma separated sequence of values enclosed in
braces.

Examples:
\textsf{{\{}111, 'b'{\}}} is a value of type \textsf{{\{}int, char{\}}};
\textsf{{\{}1.2, 3, ``456''{\}}} is a value of type \textsf{{\{}float, int, string{\}}};
\textsf{{\{}``a'', {\{}``little'', ``contrived''{\}}{\}}} is a value of type
\textsf{{\{}string, {\{}string, string{\}}{\}}}.

\Note Unlike lists (described below), tuples are constructed
and deconstructed as complete entities.  There is no such thing as the head
or tail of a tuple.  \XXX{Should we include this note at all?  Or move the
whole tuples section after lists?}

Tuples are occasionally useful for aggregating small numbers of different
types.  More often than not it is better style to use a discriminated union
type.



\section{Lists}

A list is a linear sequence of values sharing the same type.  Syntactically,
a list is a comma separated sequence of values enclosed in brackets.

Examples:
\textsf{\char`\[{}\char`\]{}} denotes the empty list, regardless of the list type;
\textsf{\char`\[{}1, 2, 3\char`\]{}} is a value of type \textsf{list(int)};
\textsf{\char`\[{}'a', 'b', 'c', 'd'\char`\]{}} is a value of type \textsf{list(char)};
\textsf{\char`\[{}\char`\[{}1\char`\]{}, \char`\[{}2, 3\char`\]{}, \char`\[{}4\char`\]{}\char`\]{}} is a value of type \textsf{list(list(int))}.

It is an error to mix values of different types inside a list because there
is no way to give a type to values such as \textsf{\char`\[{}1, ``2'', 3.4\char`\]{}}.

The \textsf{list} standard library module defines the \textsf{list} type and a wealth of
list operations.  If you forget to import the \textsf{list} module then the
compiler will issue warnings like this:

\begin{small}
\textsf{foo.m:031:   error: undefined symbol `[$|$]/2'}\\
\textsf{foo.m:031:   (the module `list' has not been imported).}
\end{small}

Lists are actually composed of two kinds of building block: \textsf{\char`\[{}\char`\]{}} (the empty
list) and \textsf{\char`\[{}$|$\char`\]{}} (the non-empty list constructor, pronounced ``cons'').  If
\textsf{X} is an \textsf{int}, say, and \textsf{Xs} a \textsf{list(int)}, then \textsf{\char`\[{}$|$\char`\]{}(X, Xs)} is a
\textsf{list(int)} whose \emph{head} (first member) is \textsf{X} and whose \emph{tail}
(list of trailing members) is \textsf{Xs}.

Lists are so common that special syntactic sugar exists for them:
\textsf{\char`\[{}X $|$ Xs\char`\]{}} is shorthand for \textsf{\char`\[{}$|$\char`\]{}(X, Xs)};
\textsf{\char`\[{}X, Y, Z $|$ Ws\char`\]{}} is shorthand for \textsf{\char`\[{}X $|$ \char`\[{}Y $|$ \char`\[{}Z $|$ Ws\char`\]{}\char`\]{}\char`\]{}};
and \textsf{\char`\[{}X, Y, Z\char`\]{}} is shorthand for \textsf{\char`\[{}X, Y, Z $|$ \char`\[{}\char`\]{}\char`\]{}}.



\section{Discriminated union types}

Discriminated unions allow the definition of new, structured types.
This example shows a representation of playing cards using discriminated
union types:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col23}{@{\ }l@{}}
\column{col45}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col37}{@{\ }l@{}}
\column{col65}{@{\ }l@{}}
\column{col56}{@{\ }l@{}}
\column{col29}{@{\ }l@{}}
\fromto{col1}{col23}{\textsf{:{\ensuremath{-}} \textbf{type} playing\_card}}
\fromto{col23}{col29}{\textsf{{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}}}}
\fromto{col29}{colend}{\textsf{card(rank, suit) ; joker.}}
\nextline
\fromto{col1}{col23}{\textsf{:{\ensuremath{-}} \textbf{type} rank}}
\fromto{col23}{col29}{\textsf{{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}}}}
\fromto{col29}{col37}{\textsf{ace}}
\fromto{col37}{col45}{\textsf{; two}}
\fromto{col45}{col56}{\textsf{; three}}
\fromto{col56}{colend}{\textsf{; four}}
\nextline
\fromto{col1}{col23}{\textsf{}}
\fromto{col23}{col29}{\textsf{;}}
\fromto{col29}{col37}{\textsf{five}}
\fromto{col37}{col45}{\textsf{; six}}
\fromto{col45}{col56}{\textsf{; seven}}
\fromto{col56}{colend}{\textsf{; eight}}
\nextline
\fromto{col1}{col23}{\textsf{}}
\fromto{col23}{col29}{\textsf{;}}
\fromto{col29}{col37}{\textsf{nine}}
\fromto{col37}{col45}{\textsf{; ten}}
\fromto{col45}{col56}{\textsf{; jack}}
\fromto{col56}{col65}{\textsf{; queen}}
\fromto{col65}{colend}{\textsf{; king.}}
\nextline
\fromto{col1}{col23}{\textsf{:{\ensuremath{-}} \textbf{type} suit}}
\fromto{col23}{col29}{\textsf{{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}}}}
\fromto{col29}{colend}{\textsf{clubs ; diamonds ; hearts ; spades.}}
\nextline
\end{ptabular}

\end{small}
The \emph{data constructors} defining the values of the discriminated union
types appear to the right of the arrows: \textsf{suit} has four possible values,
\textsf{rank} thirteen, and \textsf{playing\_card} fifty three (fifty two possible \textsf{card}
values from \textsf{card(ace, clubs)}, \textsf{card(two, clubs)}, all the way up to
\textsf{card(king, spades)}, plus the \textsf{joker} option).

An exhaustive switch on a discriminated union type must test for every
possible top-level data constructor.  That is, an exhaustive switch on a
\textsf{playing\_card} value need only test for \textsf{card(\_, \_)} and \textsf{joker} rather
than every specific \textsf{card} instance.

(The term ``discriminated union'' is used because a type denotes a union of
sets of possible values, each of which is distinguished by its data
constructor.)



\subsection*{Data constructors with named fields}

The fields of a data constructor can be named:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col37}{@{\ }l@{}}
\column{col49}{@{\ }l@{}}
\column{col59}{@{\ }l@{}}
\fromto{col1}{col37}{\textsf{:{\ensuremath{-}} \textbf{type} bank\_account {\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}} account(}}
\fromto{col37}{col49}{\textsf{name}}
\fromto{col49}{colend}{\textsf{:: string,}}
\nextline
\fromto{col1}{col37}{\textsf{}}
\fromto{col37}{col49}{\textsf{account\_no}}
\fromto{col49}{colend}{\textsf{:: int,}}
\nextline
\fromto{col1}{col37}{\textsf{}}
\fromto{col37}{col49}{\textsf{funds}}
\fromto{col49}{col59}{\textsf{:: float}}
\fromto{col59}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
We can use field names to access fields directly without having to
first deconstruct a \textsf{bank\_account} value.  That is, rather than writing
\begin{small}

\begin{ptabular}
\column{col7}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{BankAcct {\ensuremath{=}} account(Name, AcctNo, Funds),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{( \textbf{if} Funds {\ensuremath{>}}{\ensuremath{=}} RequestedSum \textbf{then}}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{colend}{\textsf{... debit RequestedSum from BankAcct ...}}
\nextline
\fromto{col1}{col7}{\hspace*{1.8em}}
\fromto{col7}{colend}{\textsf{\textbf{else}}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{... reject debit request ...}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{)}}
\nextline
\end{ptabular}

\end{small}
we can write
\begin{small}

\begin{ptabular}
\column{col7}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{( \textbf{if} BankAcct\char`\^{}funds {\ensuremath{>}}{\ensuremath{=}} RequestedSum \textbf{then}}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{colend}{\textsf{... debit RequestedSum from BankAcct ...}}
\nextline
\fromto{col1}{col7}{\hspace*{1.8em}}
\fromto{col7}{colend}{\textsf{\textbf{else}}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{... reject debit request ...}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{)}}
\nextline
\end{ptabular}

\end{small}
The Mercury compiler automatically generates a \emph{field access function}
for every named field in a data constructor.  The \textsf{bank\_account} field
access functions would be defined like this:
\begin{small}

\begin{ptabular}
\column{col30}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{col30}{\textsf{account(A, \_, \_)\char`\^{}name}}
\fromto{col30}{colend}{\textsf{{\ensuremath{=}} A.}}
\nextline
\fromto{col1}{col30}{\textsf{account(\_, B, \_)\char`\^{}account\_no}}
\fromto{col30}{colend}{\textsf{{\ensuremath{=}} B.}}
\nextline
\fromto{col1}{col30}{\textsf{account(\_, \_, C)\char`\^{}funds}}
\fromto{col30}{colend}{\textsf{{\ensuremath{=}} C.}}
\nextline
\end{ptabular}

\end{small}
Field access functions to ``update'' named fields are also generated:
\begin{small}

\begin{ptabular}
\column{col7}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{( \textbf{if} BankAcct\char`\^{}funds {\ensuremath{>}}{\ensuremath{=}} RequestedSum \textbf{then}}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{colend}{\textsf{NewBankAcct {\ensuremath{=}} (BankAcct\char`\^{}funds :{\ensuremath{=}} BankAcct\char`\^{}funds {\ensuremath{-}} RequestedSum)}}
\nextline
\fromto{col1}{col7}{\hspace*{1.8em}}
\fromto{col7}{colend}{\textsf{\textbf{else}}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{... reject debit request ...}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{)}}
\nextline
\end{ptabular}

\end{small}
The expression \textsf{(BankAcct\char`\^{}funds :{\ensuremath{=}} X)} returns a value identical to
\textsf{BankAcct} except the \textsf{funds} field will contain \textsf{X}.
The \textsf{bank\_account} field access update functions would be defined like this:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col32}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col38}{@{\ }l@{}}
\fromto{col1}{col32}{\textsf{( account(\_, B, C)\char`\^{}name}}
\fromto{col32}{col38}{\textsf{:{\ensuremath{=}} A}}
\fromto{col38}{colend}{\textsf{) {\ensuremath{=}} account(A, B, C).}}
\nextline
\fromto{col1}{col32}{\textsf{( account(A, \_, C)\char`\^{}account\_no}}
\fromto{col32}{col38}{\textsf{:{\ensuremath{=}} B}}
\fromto{col38}{colend}{\textsf{) {\ensuremath{=}} account(A, B, C).}}
\nextline
\fromto{col1}{col32}{\textsf{( account(A, B, \_)\char`\^{}funds}}
\fromto{col32}{col38}{\textsf{:{\ensuremath{=}} C}}
\fromto{col38}{colend}{\textsf{) {\ensuremath{=}} account(A, B, C).}}
\nextline
\end{ptabular}

\end{small}
Note that you do not have to name every field of a data constructor; unnamed
fields can only be ``read'' or ``updated'' by explicitly deconstructing or
constructing the entire data constructor value.

\emph{You are not allowed to use the same field name in
different types defined in the same module.}  This is an error:
\begin{small}

\begin{ptabular}
\column{col20}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col14}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{col14}{\textsf{:{\ensuremath{-}} \textbf{type} cat}}
\fromto{col14}{col20}{\textsf{{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}}}}
\fromto{col20}{colend}{\textsf{cat(name :: string).}}
\nextline
\fromto{col1}{col14}{\textsf{:{\ensuremath{-}} \textbf{type} dog}}
\fromto{col14}{col20}{\textsf{{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}}}}
\fromto{col20}{colend}{\textsf{dog(name :: string).}}
\nextline
\end{ptabular}

\end{small}
Instead use distinct field names, such as \textsf{cat\_name} and \textsf{dog\_name},
or use a single type with two data constructors (the same field
name can be used in different data constructors of the same type.)

\emph{A field access may fail if a data type has more than one data
constructor.}  For example, given
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{type} playing\_card {\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}} card(card\_rank :: rank, card\_suit :: suit) ; joker.}}
\nextline
\end{ptabular}

\end{small}
A goal featuring the expression \textsf{Card\char`\^{}card\_rank} will fail if \textsf{Card} happens
to be a \textsf{joker}.

\emph{Field accesses can be chained together.}
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{type} employee {\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}} employee(id :: int, contact :: contact\_details).}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{type} contact\_details {\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}} contact\_details(address :: string, phone :: int).}}
\nextline
\end{ptabular}

\end{small}
If \textsf{Employee} contains a value of type \textsf{employee} then the expression
\textsf{Employee\char`\^{}contact\char`\^{}address} is the \textsf{address} field of the \textsf{contact}
field of the \textsf{employee} constructor.

\emph{Nested fields can be updated.}
The expression \textsf{Employee\char`\^{}contact\char`\^{}address :{\ensuremath{=}} NewAddr} denotes a copy of
\textsf{Employee} with the \textsf{address} field of the \textsf{contact} field of the \textsf{employee}
data constructor updated to hold \textsf{NewAddr}.

Parentheses can change the meaning of an update expression:\\
\textsf{(Employee\char`\^{}contact)\char`\^{}address :{\ensuremath{=}} NewAddr} denotes an updated copy of the
\textsf{contact} field of the \textsf{employee} data constructor (\ie the type of this
expression is \textsf{contact\_details}, not \textsf{employee}.)

One final remark: it is also possible to explicitly define field access
functions, for instance for ``virtual fields'' that are computed rather than
stored in a data constructor or for update functions that perform sanity
checks on their arguments.  User defined field access functions are
described fully in Chapter \XXX{}.



\section{Polymorphic types}

\emph{Polymorphic} types are types parameterised by
\emph{type variables}.  A polymorphic binary tree type carrying values at
the branches could be defined like this:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{type} tree(T) {\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}} leaf ; branch(tree(T), T, tree(T)).}}
\nextline
\end{ptabular}

\end{small}
This is just a discriminated union type with a type argument, \textsf{T}.  \textsf{T} can
match any type at all, so \textsf{tree(int)}, \textsf{tree(string)}, \textsf{tree(list(char))} are
all refinements of \textsf{tree(T)}.

Examples:
\textsf{branch(branch(leaf, 1, leaf), 2, branch(leaf, 3, leaf))}
is a value of type \textsf{tree(int)};
\textsf{branch(leaf, {\{}'a', 65{\}}, branch(leaf, {\{}'b', 66{\}}, leaf))}
is a value of type \textsf{tree({\{}char, int{\}})}; and
\textsf{leaf} is a value of every \textsf{tree} type.

The canonical example of a polymorphic data type is the \textsf{list} type defined
in the \textsf{list} standard library module:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{type} list(T) {\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}} \char`\[{}\char`\]{} ; \char`\[{}T $|$ list(T)\char`\]{}.}}
\nextline
\end{ptabular}

\end{small}
The \textsf{maybe} type defined in the \textsf{std\_util} standard library module is
another useful polymorphic type:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{type} maybe(T) {\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}} no ; yes(T).}}
\nextline
\end{ptabular}

\end{small}
This type is commonly used to represent optional values (had the
database community known about \textsf{maybe} types they never would have invented
\textsf{NULL}s and wrecked the relational model\ldots)

Once one has polymorphic types, it is natural to want to define polymorphic
predicates and functions.  The \textsf{list} module \textsf{length} function works for
lists of every type thanks to the type argument in its signature (it is
just convention that we have reused the name \textsf{T} here --- any variable name
would do):
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col19}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{func} length(list(T)) {\ensuremath{=}} int.}}
\nextline
\nextline
\fromto{col1}{col19}{\textsf{length(\char`\[{}\char`\]{})}}
\fromto{col19}{colend}{\textsf{{\ensuremath{=}} 0.}}
\nextline
\fromto{col1}{col19}{\textsf{length(\char`\[{}\_ $|$ Xs\char`\]{})}}
\fromto{col19}{colend}{\textsf{{\ensuremath{=}} 1 {\ensuremath{+}} length(Xs).}}
\nextline
\end{ptabular}

\end{small}
The first clause
defines the length of the empty list to be \textsf{0}; the second clause defines
the length of a non-empty list \textsf{\char`\[{}\_ $|$ Xs\char`\]{}} to be \textsf{1} for the head (the
underscore says we don't care what that happens to be) plus the length of
the tail, \textsf{Xs}.

Here is an example of a polymorphic predicate to decide whether a given
value resides in an ordered binary tree of the type we defined at the start
of this section (by ordered we mean that smaller values appear to the left
of larger values in the tree):
\begin{small}

\begin{ptabular}
\column{col21}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col26}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} search(tree(T)::in, T::in) \textbf{is} \textbf{semidet}.}}
\nextline
\nextline
\fromto{col1}{col26}{\textsf{search(branch(L, X, R),}}
\fromto{col26}{colend}{\textsf{Y) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{O {\ensuremath{=}} ordering(X, Y),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{col9}{\textsf{(}}
\fromto{col9}{col21}{\textsf{O {\ensuremath{=}} ({\ensuremath{<}}),}}
\fromto{col21}{colend}{\textsf{search(R, Y)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{col9}{\textsf{;}}
\fromto{col9}{colend}{\textsf{O {\ensuremath{=}} ({\ensuremath{=}})}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{col9}{\textsf{;}}
\fromto{col9}{col21}{\textsf{O {\ensuremath{=}} ({\ensuremath{>}}),}}
\fromto{col21}{colend}{\textsf{search(L, Y)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
The \textsf{ordering} function is built-in to Mercury and compares any two values
of the same type, returning a result of type \textsf{comparison\_result}:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{type} comparison\_result {\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}} ({\ensuremath{<}}) ; ({\ensuremath{=}}) ; ({\ensuremath{>}}).}}
\nextline
\end{ptabular}

\end{small}
As you can see, data constructor names don't necessarily have to be
alphanumeric.  These data constructor names must appear in parentheses to
stop the Mercury parser from interpreting them as infix operators.  This is
also an example of \emph{overloading}, where the same name may be used for
more than one purpose provided there is no ambiguity.

After calling \textsf{ordering}, \textsf{search} switches on \textsf{O} to decide what to do
next: if the value at the current \textsf{branch}, \textsf{X}, is less than the value we
are searching for, \textsf{Y}, then search should procede down the right subtree,
\textsf{R}.  If \textsf{X {\ensuremath{=}} Y} then the search terminates successfully.  Otherwise, \textsf{X} is
greater than \textsf{Y} and the search should procede down the left subtree, \textsf{L}.
The absence of a clause for \textsf{leaf} values means that any search that reaches
a \textsf{leaf} will fail.



\section{Equivalence types}

Readability is often improved by giving simple names to complex types or
by using more meaningful names for a specific uses of general types:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col17}{@{\ }l@{}}
\column{col45}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col28}{@{\ }l@{}}
\fromto{col1}{col17}{\textsf{:{\ensuremath{-}} \textbf{type} height}}
\fromto{col17}{col28}{\textsf{{\ensuremath{=}}{\ensuremath{=}} float.}}
\fromto{col28}{colend}{\textsf{\% In metres.}}
\nextline
\fromto{col1}{col17}{\textsf{:{\ensuremath{-}} \textbf{type} radius}}
\fromto{col17}{col28}{\textsf{{\ensuremath{=}}{\ensuremath{=}} float.}}
\fromto{col28}{colend}{\textsf{\% In metres.}}
\nextline
\fromto{col1}{col17}{\textsf{:{\ensuremath{-}} \textbf{type} volume}}
\fromto{col17}{col28}{\textsf{{\ensuremath{=}}{\ensuremath{=}} float.}}
\fromto{col28}{colend}{\textsf{\% In cubic metres.}}
\nextline
\nextline
\fromto{col1}{col45}{\textsf{:{\ensuremath{-}} \textbf{func} volume\_of\_cylinder(height, radius)}}
\fromto{col45}{colend}{\textsf{{\ensuremath{=}} volume.}}
\nextline
\fromto{col1}{col45}{\textsf{:{\ensuremath{-}} \textbf{func} volume\_of\_sphere(radius)}}
\fromto{col45}{colend}{\textsf{{\ensuremath{=}} volume.}}
\nextline
\end{ptabular}

\end{small}
\XXX{Move this stuff about comments to chapter 1.}
(The \textsf{\%} sign introduces a comment, which extends to the end of the line.)
Here we define the types \textsf{height}, \textsf{radius} and \textsf{volume} to be equivalent to
(\ie interchangeable with) type \textsf{float}.  We could have just declared
\textsf{volume\_of\_cylinder} using
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{func} volume\_of\_cylinder(float, float) {\ensuremath{=}} float.}}
\nextline
\end{ptabular}

\end{small}
but then we would be morally obliged to include a comment explaining which
arguments correspond to which measurements.

Equivalence types can also be parameterized.  For example:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col33}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{col33}{\textsf{:{\ensuremath{-}} \textbf{type} dictionary(Key, Value)}}
\fromto{col33}{colend}{\textsf{{\ensuremath{=}}{\ensuremath{=}} list({\{}Key, Value{\}}).}}
\nextline
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{\% search(Dict, Key, Value) unifies Value \textbf{if} there \textbf{is} an association}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{\% for Key in Dict, but fails otherwise.}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{\%}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} search(dictionary(Key, Value)::in, Key::in, Value::out) \textbf{is} \textbf{semidet}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{search(\char`\[{}{\{}K, V{\}} $|$ Dict\char`\]{}, Key, Value) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{( \textbf{if} Key {\ensuremath{=}} K \textbf{then} Value {\ensuremath{=}} V \textbf{else} search(Dict, Key, Value) ).}}
\nextline
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{\% set(Dict, Key, Value) returns an updated version of Dict}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{\% associating Key with Value.}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{\%}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{func} set(dictionary(Key, Value), Key, Value) {\ensuremath{=}} dictionary(Key, Value).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{set(Dict, Key, Value) {\ensuremath{=}} \char`\[{}{\{}Key, Value{\}} $|$ Dict\char`\]{}.}}
\nextline
\end{ptabular}

\end{small}



\section{Abstract types}

It is virtually always a Bad Idea to reveal implementation detail to the
user of a module.  Mercury ensures that predicate and function
\emph{definitions} are private to a module because they cannot appear in the
\textsf{\textbf{interface}} section of a module.  Abstract types allow the same kind of
information hiding for types.  An abstract type is one that is
\emph{declared} in the \textsf{\textbf{interface}} section of a module, but \emph{defined} in
the \textsf{\textbf{implementation}} section.

Here's how we would use abstract types if we wanted to export the
\textsf{dictionary} type defined above:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{module} dictionary.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{interface}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{type} dictionary(Key, Value).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} search(dictionary(Key, Value)::in, Key::in, Value::out) \textbf{is} \textbf{semidet}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{func} set(dictionary(Key, Value), Key, Value) {\ensuremath{=}} dictionary(Key, Value).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{implementation}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} list.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{type} dictionary(Key, Value) {\ensuremath{=}}{\ensuremath{=}} list({\{}Key, Value{\}}).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{search(\char`\[{}{\{}K, V{\}} $|$ Dict\char`\]{}, Key, Value) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{( \textbf{if} Key {\ensuremath{=}} K \textbf{then} Value {\ensuremath{=}} V \textbf{else} search(Dict, Key, Value) ).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{set(Dict, Key, Value) {\ensuremath{=}} \char`\[{}{\{}Key, Value{\}} $|$ Dict\char`\]{}.}}
\nextline
\end{ptabular}

\end{small}
Observe the \textsf{\textbf{type}} declaration in the \textsf{\textbf{interface}} section: it gives the name
of the type and its arguments, but nothing else.  Further down, in the
\textsf{\textbf{implementation}} section, we give a definition for \textsf{dictionary}.  At some
later point we may reimplement \textsf{dictionary} as an ordered list or
binary tree or some other more efficient structure.  Such a change would not
affect the interface of the \textsf{dictionary} module (because \textsf{dictionary} is an
abstract type), so no changes would be required by users of the module.



\section{Higher order types}

Mercury considers functions and predicates to be values just as much as it
does \textsf{int}s, \textsf{string}s and \textsf{list}s.  Consider the higher order \textsf{map}
function (as defined in the \textsf{list} standard library module) which takes a
function from \textsf{T$_{1}$} values to \textsf{T$_{2}$} values, a list of \textsf{T$_{1}$} values, and returns
a list of \textsf{T$_{2}$} values:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col19}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{func} map(\textbf{func}(T$_{1}$) {\ensuremath{=}} T$_{2}$, list(T$_{1}$)) {\ensuremath{=}} list(T$_{2}$).}}
\nextline
\nextline
\fromto{col1}{col19}{\textsf{map(\_, \char`\[{}\char`\]{})}}
\fromto{col19}{colend}{\textsf{{\ensuremath{=}} \char`\[{}\char`\]{}.}}
\nextline
\fromto{col1}{col19}{\textsf{map(F, \char`\[{}X $|$ Xs\char`\]{})}}
\fromto{col19}{colend}{\textsf{{\ensuremath{=}} \char`\[{}F(X) $|$ map(F, Xs)\char`\]{}.}}
\nextline
\end{ptabular}

\end{small}
The first clause says that mapping over the empty list returns the empty
list.  The second clause says that mapping the function \textsf{F} over the
non-empty list \textsf{\char`\[{}X $|$ Xs\char`\]{}} is the list whose head is \textsf{F(X)} (\ie the result
of applying \textsf{F} to \textsf{X}) and whose tail is the result of mapping \textsf{F} over
\textsf{Xs}.

The thing to observe here is the argument type \textsf{\textbf{func}(T$_{1}$) {\ensuremath{=}} T$_{2}$}, which
illustrates the syntax for function types.

This next example illustrates the syntax for predicate types (this predicate
is also defined in the \textsf{list} standard library module):
\begin{small}

\begin{ptabular}
\column{col20}{@{\ }l@{}}
\column{col8}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col14}{@{\ }l@{}}
\column{col43}{@{\ }l@{}}
\column{col44}{@{\ }l@{}}
\column{col26}{@{\ }l@{}}
\column{col53}{@{\ }l@{}}
\column{col72}{@{\ }l@{}}
\column{col63}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col55}{@{\ }l@{}}
\column{col37}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{pred}}}
\fromto{col10}{col43}{\textsf{filter(\textbf{pred}(T),}}
\fromto{col43}{col53}{\textsf{list(T),}}
\fromto{col53}{col63}{\textsf{list(T),}}
\fromto{col63}{col72}{\textsf{list(T)}}
\fromto{col72}{colend}{\textsf{).}}
\nextline
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{mode}}}
\fromto{col10}{col43}{\textsf{filter(in(\textbf{pred}(in) \textbf{is} \textbf{semidet}),}}
\fromto{col43}{col53}{\textsf{in,}}
\fromto{col53}{col63}{\textsf{out,}}
\fromto{col63}{col72}{\textsf{out}}
\fromto{col72}{colend}{\textsf{) \textbf{is} \textbf{det}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{filter(\_, \char`\[{}\char`\]{}, \char`\[{}\char`\]{}, \char`\[{}\char`\]{}).}}
\nextline
\fromto{col1}{colend}{\textsf{filter(P, \char`\[{}X $|$ Xs\char`\]{}, Ys, Zs) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{filter(P, Xs, Ys$_{0}$, Zs$_{0}$),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{col8}{\textsf{(}}
\fromto{col8}{col14}{\textsf{\textbf{if}}}
\fromto{col14}{col20}{\textsf{P(X)}}
\fromto{col20}{col26}{\textsf{\textbf{then}}}
\fromto{col26}{col37}{\textsf{Ys {\ensuremath{=}} \char`\[{}X $|$}}
\fromto{col37}{col44}{\textsf{Ys$_{0}$\char`\]{},}}
\fromto{col44}{col55}{\textsf{Zs {\ensuremath{=}}}}
\fromto{col55}{colend}{\textsf{Zs$_{0}$}}
\nextline
\fromto{col1}{col20}{\textsf{}}
\fromto{col20}{col26}{\textsf{\textbf{else}}}
\fromto{col26}{col37}{\textsf{Ys {\ensuremath{=}}}}
\fromto{col37}{col44}{\textsf{Ys$_{0}$,}}
\fromto{col44}{col55}{\textsf{Zs {\ensuremath{=}} \char`\[{}X $|$}}
\fromto{col55}{colend}{\textsf{Zs$_{0}$\char`\]{}}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
the goal \textsf{filter(P, As, Bs, Cs)} unifies \textsf{Bs} with the list of members of
\textsf{As} that satisfy \textsf{P} and unifies \textsf{Cs} with the list of members of \textsf{As}
that don't.  The first clause says that filtering the empty list yeilds two
empty lists.  The second clause says that filtering \textsf{\char`\[{}X $|$ Xs\char`\]{}} through the
predicate \textsf{P} is the result of filtering \textsf{Xs} through \textsf{P} and adding \textsf{X} to
the first result if \textsf{P(X)} (\ie if \textsf{P} succeeds given \textsf{X}), or adding \textsf{X} to
the second result if it doesn't.

The first new thing here is the separation of \emph{type}
information from \emph{mode} information in the declarations for \textsf{filter}.
Mercury requires a separate \textsf{\textbf{mode}} declaration if you do not supply mode and
determinism details in the \textsf{\textbf{pred}} declaration.
The two declarations could be combined thus
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col18}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{col18}{\textsf{:{\ensuremath{-}} \textbf{pred} filter(}}
\fromto{col18}{colend}{\textsf{\textbf{pred}(T)::in(\textbf{pred}(in) \textbf{is} \textbf{semidet}),}}
\nextline
\fromto{col1}{col18}{\textsf{}}
\fromto{col18}{colend}{\textsf{list(T)::in, list(T)::out, list(T)::out) \textbf{is} \textbf{det}.}}
\nextline
\end{ptabular}

\end{small}
However, having separate \textsf{\textbf{pred}} and \textsf{\textbf{mode}} declarations 
highlights that the \emph{type} of \textsf{filter}'s higher order argument
is written \textsf{\textbf{pred}(T)}.  (Separate \textsf{\textbf{mode}} declarations are examined in more
detail in Chapter \XXX{}.)  \XXX{Do I need to explain the parameterised \textsf{in}
mode?}

In general, higher order programming with predicates is more complicated
than with functions because of the need to also specify the modes for the
higher order arguments.



\section{\textsf{univ}, the universal type}

The \textsf{univ} type provides support for dynamically typed programming.
Mercury's type system is so expressive that \textsf{univ} is hardly ever necessary.
However, should you require it, here is (a slightly abridged version of) the
interface to \textsf{univ} as defined in the \textsf{std\_util} standard library module:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{type}}}
\fromto{col10}{colend}{\textsf{univ.}}
\nextline
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{func}}}
\fromto{col10}{colend}{\textsf{univ(T) {\ensuremath{=}} univ.}}
\nextline
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{pred}}}
\fromto{col10}{colend}{\textsf{univ\_to\_type(univ::in, T::out) \textbf{is} \textbf{semidet}.}}
\nextline
\end{ptabular}

\end{small}
The \textsf{univ} function turns an argument of any type into a \textsf{univ} value (this
is an example of overloading a name for a type and a function).  The
\textsf{univ\_to\_type} predicate turns a \textsf{univ} value into a value of type \textsf{T} (what
\textsf{T} denotes depends upon the context of the call to \textsf{univ\_to\_type}) if that
is the type of value contained in the \textsf{univ}, and fails otherwise.

We said earlier that a value like \textsf{\char`\[{}1, ``2'', 3.4\char`\]{}} would be rejected because
it cannot be given a type.  This is true, but we can achieve much the same
end by writing \textsf{\char`\[{}univ(1), univ(``2''), univ(3.4)\char`\]{}}, which does have a type,
\textsf{list(univ)}.

To illustrate the use of \textsf{univ\_to\_type}, here is a program to print out
\textsf{univ}s:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col34}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{module} print\_univs.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{interface}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} io.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} main(io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{implementation}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} list, std\_util, string.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{col34}{\textsf{print\_univ(univ(1),}}
\fromto{col34}{colend}{\textsf{!IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{col34}{\textsf{print\_univ(univ(``2''),}}
\fromto{col34}{colend}{\textsf{!IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{col34}{\textsf{print\_univ(univ(3.4),}}
\fromto{col34}{colend}{\textsf{!IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{col34}{\textsf{print\_univ(univ({\{}5, 6, 7{\}}),}}
\fromto{col34}{colend}{\textsf{!IO).}}
\nextline
\end{ptabular}

\end{small}
\begin{small}

\begin{ptabular}
\column{col7}{@{\ }l@{}}
\column{col79}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col16}{@{\ }l@{}}
\column{col36}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col85}{@{\ }l@{}}
\column{col76}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} print\_univ(univ::in, io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{print\_univ(U, !IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{col16}{\textsf{( \textbf{if}}}
\fromto{col16}{col36}{\textsf{univ\_to\_type(U, C)}}
\fromto{col36}{col76}{\textsf{\textbf{then} io.format(``a char, \%c{\ensuremath{\backslash}}n'',}}
\fromto{col76}{col79}{\textsf{\char`\[{}}}
\fromto{col79}{col85}{\textsf{c(C)}}
\fromto{col85}{colend}{\textsf{\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col7}{\hspace*{1.8em}}
\fromto{col7}{col16}{\textsf{\textbf{else} \textbf{if}}}
\fromto{col16}{col36}{\textsf{univ\_to\_type(U, S)}}
\fromto{col36}{col76}{\textsf{\textbf{then} io.format(``a string, {\ensuremath{\backslash}}``\%s{\ensuremath{\backslash}}''{\ensuremath{\backslash}}n'',}}
\fromto{col76}{col79}{\textsf{\char`\[{}}}
\fromto{col79}{col85}{\textsf{s(S)}}
\fromto{col85}{colend}{\textsf{\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col7}{\textsf{}}
\fromto{col7}{col16}{\textsf{\textbf{else} \textbf{if}}}
\fromto{col16}{col36}{\textsf{univ\_to\_type(U, I)}}
\fromto{col36}{col76}{\textsf{\textbf{then} io.format(``an int, \%d{\ensuremath{\backslash}}n'',}}
\fromto{col76}{col79}{\textsf{\char`\[{}}}
\fromto{col79}{col85}{\textsf{i(I)}}
\fromto{col85}{colend}{\textsf{\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col7}{\textsf{}}
\fromto{col7}{col16}{\textsf{\textbf{else} \textbf{if}}}
\fromto{col16}{col36}{\textsf{univ\_to\_type(U, F)}}
\fromto{col36}{col76}{\textsf{\textbf{then} io.format(``a float, \%f{\ensuremath{\backslash}}n'',}}
\fromto{col76}{col79}{\textsf{\char`\[{}}}
\fromto{col79}{col85}{\textsf{f(F)}}
\fromto{col85}{colend}{\textsf{\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col7}{\textsf{}}
\fromto{col7}{col16}{\textsf{\textbf{else}}}
\fromto{col16}{colend}{\textsf{io.format(``no idea...{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
Compiling and running this program, we get
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{{\ensuremath{>}} mmc {\ensuremath{-}}{\ensuremath{-}}make print\_univs}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/int3s/print\_univs.int3}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/cs/print\_univs.c}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/os/print\_univs.o}}
\nextline
\fromto{col1}{colend}{\textsf{Making print\_univs}}
\nextline
\fromto{col1}{colend}{\textsf{{\ensuremath{>}} ./print\_univs}}
\nextline
\fromto{col1}{colend}{\textsf{an int, 1}}
\nextline
\fromto{col1}{colend}{\textsf{a string, ``2''}}
\nextline
\fromto{col1}{colend}{\textsf{a float, 3.400000}}
\nextline
\fromto{col1}{colend}{\textsf{no idea...}}
\nextline
\end{ptabular}

\end{small}
So how does \textsf{univ\_to\_type} know that \textsf{C} is a \textsf{char}, \textsf{S} a string, and so
forth?  The answer is the compiler automatically infers these types from
context: the argument of a \textsf{c} data constructor in an \textsf{io.format} argument
list must be a \textsf{char}; the argument of an \textsf{s} data constructor must be a
\textsf{string}; similarly \textsf{I} must be an \textsf{int} and \textsf{F} a \textsf{float}.  Information
about each result type is supplied to the \textsf{univ\_to\_type} calls via extra
arguments inserted by the Mercury compiler.

Full details of the run-time type information (RTTI) scheme are beyond the
scope of this book.  The interested reader is referred to the documentation
for the \textsf{std\_util} module in the Mercury Library Reference Manual and the
relevant parts of the Mercury Reference Manual.



\section{Useful types defined in the Mercury standard library}

The Mercury standard library defines many useful types, the most common of
which are examined in more detail in Chapter \XXX{}.  These include \textsf{bool}
for boolean values, \textsf{graph} for graph processing, \textsf{list} for stacks and
sequences, \textsf{map} for dictionaries, \textsf{queue} for first-in first-out (FIFO)
queues, \textsf{pqueue} for priority queues, \textsf{random} for random numbers, and \textsf{set}
for sets.  The \textsf{std\_util} module defines miscellaneous utility types such as
\textsf{univ}, \textsf{maybe}, \textsf{unit} (the ``dummy'' type), and \textsf{pair}.  Many more types
are defined in the standard library, but the above suffice for the majority
of data structures.



\section{More advanced types\ldots}

Mercury's type system includes two more advanced aspects each with a
separate chapter.  Chapter \XXX{} describes type classes and existentially
quantified types which exist to support object oriented programming styles.
Chapter \XXX{} describes types with user-defined equality and comparison
relations; these are so-called \emph{non-canonical} types in which a given
semantic value may be represented in more than one way.



\XXX{I haven't really mentioned type inference, nor have I mentioned
explicit type qualification of local vars.}
\setcounter{chapter}{2}
% vim: ft=tex ff=unix ts=4 sw=4 et tw=76



\chapter{The Mercury mode system}

Last edited Jan 27 17:46

Mercury programs are really just logical formulae written down using a
particular syntax.  The Mercury compiler, however, needs extra information
to turn these logical formulae into something the computer can execute.
Specifically, it needs to know which arguments of a predicate 
can be inputs and which outputs.  This information is conveyed using
\emph{argument modes} and \emph{determinism categories}.

This chapter explains the mode system and how it is used.

\section{Predicates and procedures}

Every predicate must have a declaration specifying which arguments can be
inputs and which outputs.  Consider the following implementation of a
telephone directory in which phone numbers can be looked-up by name:
\begin{small}

\begin{ptabular}
\column{col21}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{pred}}}
\fromto{col10}{colend}{\textsf{phone(string::in, int::out) \textbf{is} \textbf{semidet}.}}
\nextline
\nextline
\fromto{col1}{col21}{\textsf{phone(``Ian'',}}
\fromto{col21}{colend}{\textsf{66532).}}
\nextline
\fromto{col1}{col21}{\textsf{phone(``Julien'',}}
\fromto{col21}{colend}{\textsf{66532).}}
\nextline
\fromto{col1}{col21}{\textsf{phone(``Peter'',}}
\fromto{col21}{colend}{\textsf{66540).}}
\nextline
\fromto{col1}{col21}{\textsf{phone(``Ralph'',}}
\fromto{col21}{colend}{\textsf{66532).}}
\nextline
\fromto{col1}{col21}{\textsf{phone(``Zoltan'',}}
\fromto{col21}{colend}{\textsf{66514).}}
\nextline
\end{ptabular}

\end{small}
The style of \textsf{\textbf{pred}} declaration used here is called a \textsf{\textbf{pred}}-\textsf{\textbf{mode}}
declaration and is syntactic sugar for two separate declarations:
\begin{small}

\begin{ptabular}
\column{col31}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col25}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{pred}}}
\fromto{col10}{col25}{\textsf{phone(string,}}
\fromto{col25}{colend}{\textsf{int).}}
\nextline
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{mode}}}
\fromto{col10}{col25}{\textsf{phone(in,}}
\fromto{col25}{col31}{\textsf{out)}}
\fromto{col31}{colend}{\textsf{\textbf{is} \textbf{semidet}.}}
\nextline
\end{ptabular}

\end{small}
The plain \textsf{\textbf{pred}} declaration tells us the argument types; the \textsf{\textbf{mode}}
declaration tells us the \emph{argument modes} (\textsf{in} or \textsf{out}) and the
corresponding \emph{determinism category} (\textsf{\textbf{semidet}}).

It is natural to want to call some predicates in more than one way --- if we
want to use \textsf{phone} to perform ``reverse look-ups'', for instance.  In such
cases more than one \textsf{\textbf{mode}} declaration is necessary (\textsf{\textbf{pred}}-\textsf{\textbf{mode}} shorthand
can only be used for singly-moded predicates).

To allow reverse look-ups with \textsf{phone} all that is necessary is to (a) use
separate \textsf{\textbf{pred}} and \textsf{\textbf{mode}} declarations and (b) add an extra \textsf{\textbf{mode}}
declaration:
\begin{small}

\begin{ptabular}
\column{col31}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col25}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{pred}}}
\fromto{col10}{col25}{\textsf{phone(string,}}
\fromto{col25}{colend}{\textsf{int).}}
\nextline
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{mode}}}
\fromto{col10}{col25}{\textsf{phone(in,}}
\fromto{col25}{col31}{\textsf{out)}}
\fromto{col31}{colend}{\textsf{\textbf{is} \textbf{semidet}.}}
\nextline
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{mode}}}
\fromto{col10}{col25}{\textsf{phone(out,}}
\fromto{col25}{col31}{\textsf{in)}}
\fromto{col31}{colend}{\textsf{\textbf{is} \textbf{nondet}.}}
\nextline
\end{ptabular}

\end{small}

The first \textsf{\textbf{mode}} declaration
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{mode}}}
\fromto{col10}{colend}{\textsf{phone(in, out) \textbf{is} \textbf{semidet}.}}
\nextline
\end{ptabular}

\end{small}
says that if we call \textsf{phone} giving its first argument as an input and
taking its second as an output, then the result is semideterministic: every
name in the directory appears exactly once, but not all names are
listed.  The goal \textsf{phone(``Harald'', HaraldsNum)} will obviously fail, but
\textsf{phone(``Ralph'', RalphsNum)} will succeed unifying \textsf{RalphsNum} with \textsf{66532}.

The second \textsf{\textbf{mode}} declaration
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{mode}}}
\fromto{col10}{colend}{\textsf{phone(out, in) \textbf{is} \textbf{nondet}.}}
\nextline
\end{ptabular}

\end{small}
says that if we call \textsf{phone} with its second
argument given as input and take its first argument as output, then the
result is nondeterministic: it can fail because the goal
\textsf{phone(Person, 12345)} will fail, but the goal \textsf{phone(Person, 66532)}
has no less than three possible solutions --- \textsf{Person {\ensuremath{=}} ``Ian''},
\textsf{Person {\ensuremath{=}} ``Julien''}, and \textsf{Person {\ensuremath{=}} ``Ralph''} --- each of which will be
computed on backtracking.

\Note Each \textsf{\textbf{mode}} declaration specifies a \emph{procedure} to be derived
from the predicate definition.  The compiler generates code separately for
each procedure of a predicate, reordering goals to ensure that every
variable is instantiated (\eg by some earlier unification or call) before it
is used in an input in a unification or call.  Mode information is also used
to decide whether a unification with a data constructor is a construction or
deconstruction.

The compiler verifies that the determinism category for a procedure
properly describes the behaviour of the procedure.  The compiler will
issue an error if a procedure can fail or have multiple solutions when its
declared determinism category says otherwise.  Moreover, the compiler will
report an error if a deterministic switch is incomplete, telling you
which cases have been missed (Prolog programmers dream of having error
detection like this\ldots)

\subsection*{Implied modes}

An \emph{implied mode} is one where an output argument is supplied as
an input in a procedure call.  Consider the goal \textsf{phone(``Ralph'', 66540)}.
The compiler gets around this situation by placing a new, temporary variable
in the output position and then adding a unification goal, giving
\textsf{phone(``Ralph'', Tmp), Tmp {\ensuremath{=}} 66540}.

\section{The determinism categories}

A determinism category tells us whether a particular procedure can fail and
whether it may have more than one solution:

\begin{tabular}{lr}
Determinism category    & Number of solutions \\
\hline
\textsf{\textbf{det}}                   & $1$ \\
\textsf{\textbf{semidet}}               & $\leq 1$ \\
\textsf{\textbf{multi}}                 & $\geq 1$ \\
\textsf{\textbf{nondet}}                & $\geq 0$ \\
\textsf{\textbf{failure}}               & $0$ \\
\end{tabular}

There are three other determinsm categories that are only occasionally
needed: \textsf{\textbf{erroneous}}, which is used for predicates that only terminate by
throwing an exception (exceptions are described in Chapter \XXX{}), and
\textsf{\textbf{cc\_multi}} and \textsf{\textbf{cc\_nondet}} which are used for committed-choice
nondeterminism (see Chapter \XXX{}).

\subsection*{Some examples}

\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} square(int::in, int::out) \textbf{is} \textbf{det}.}}
\nextline
\fromto{col1}{colend}{\textsf{square(X, X {\ensuremath{*}} X).}}
\nextline
\end{ptabular}

\end{small}
\textsf{square} is \textsf{\textbf{det}}: it cannot fail and every input has a single solution for
the output.

\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} absolute\_square\_root(float::in, float::out) \textbf{is} \textbf{semidet}}}
\nextline
\fromto{col1}{colend}{\textsf{absolute\_square\_root(X, AbsSqrtX) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{X {\ensuremath{>}}{\ensuremath{=}} 0.0,}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{AbsSqrtX {\ensuremath{=}} math.sqrt(X).}}
\nextline
\end{ptabular}

\end{small}
\textsf{absolute\_square\_root} is \textsf{\textbf{semidet}}: it fails for negative inputs while
non-negative inputs each have a single solution.

\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} small\_prime(int::out) \textbf{is} \textbf{multi}.}}
\nextline
\fromto{col1}{colend}{\textsf{small\_prime(2).}}
\nextline
\fromto{col1}{colend}{\textsf{small\_prime(3).}}
\nextline
\fromto{col1}{colend}{\textsf{small\_prime(5).}}
\nextline
\fromto{col1}{colend}{\textsf{small\_prime(7).}}
\nextline
\end{ptabular}

\end{small}
\textsf{small\_prime} is \textsf{\textbf{multi}}: it cannot fail and it has more than one solution.

\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} small\_prime\_factor(int::in, int::out) \textbf{is} \textbf{nondet}.}}
\nextline
\fromto{col1}{colend}{\textsf{small\_prime\_factor(X, P) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{small\_prime(P),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{X mod P {\ensuremath{=}} 0.}}
\nextline
\end{ptabular}

\end{small}
\textsf{small\_prime\_factor} is \textsf{\textbf{nondet}}: \textsf{small\_prime\_factor(11, A)}, for instance,
will fail, but \textsf{small\_prime\_factor(6, A)} has solutions \textsf{A {\ensuremath{=}} 2} and \textsf{A {\ensuremath{=}} 3}.

Finally, the built-in predicate \textsf{\textbf{false}}, which takes no arguments, has
determinism \textsf{\textbf{failure}}: it never succeeds.  The opposite of \textsf{\textbf{false}} is the
built-in predicate \textsf{\textbf{true}} which has no arguments and always succeeds (and is
therefore \textsf{\textbf{det}}).

\Note The determinism category of a goal with no output arguments is either
\textsf{\textbf{det}}, \textsf{\textbf{semidet}}, or \textsf{\textbf{failure}}.  Consider the following:
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} has\_small\_prime\_factor(int::in) \textbf{is} \textbf{semidet}.}}
\nextline
\fromto{col1}{colend}{\textsf{has\_small\_prime\_factor(X) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{small\_prime(P),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{X mod P {\ensuremath{=}} 0.}}
\nextline
\end{ptabular}

\end{small}
Because there are no outputs, Mercury ensures that the goal
\\\textsf{has\_small\_prime\_factor(15)}, say, will not succeed more than once, even
though \textsf{small\_prime(P)} has two solutions, \textsf{P {\ensuremath{=}} 3} and \textsf{P {\ensuremath{=}} 5}, satisfying 
\textsf{15 mod P {\ensuremath{=}} 0}.

\section{Determinism}

These rules specify how determinism categories for compound goals are
derived (with a little experience this quickly becomes second nature).
The determinism category of a goal is derived from the instantiation state
of its arguments at the time the goal is executed.

\Note Remember that the compiler reorders the goals in a predicate
separately for each \textsf{\textbf{mode}} declaration for the predicate.  A running program
does not make decisions about which procedures should be executed when
calling predicates; this is decided in advance by the Mercury compiler.

\subsection*{Unifications}

Whether a unification is a construction, deconstruction, assignment or
equality test depends upon which variables are instantiated and which are
not at the time the unification is executed.

A unification \textsf{X {\ensuremath{=}} data\_ctor(Y$_{1}$, Y$_{2}$, Y$_{3}$)} is a \emph{construction} if \textsf{Y$_{1}$},
\textsf{Y$_{2}$}, and \textsf{Y$_{3}$} are initially instantiated and \textsf{X} is not.  Constructions are
always \textsf{\textbf{det}}.  Afterwards, \textsf{X} will be instantiated.

A unification \textsf{X {\ensuremath{=}} data\_ctor(Y$_{1}$, Y$_{2}$, Y$_{3}$)} is a \emph{deconstruction} if \textsf{X}
is initially instantiated.  Afterwards, \textsf{Y$_{1}$}, \textsf{Y$_{2}$}, and \textsf{Y$_{3}$} will be
instantiated.  Deconstructions are almost always \textsf{\textbf{semidet}} (in certain
circumstances a deconstruction may have determinism category \textsf{\textbf{det}} if it is
guaranteed to succeed or \textsf{\textbf{failure}} if it is guaranteed to fail).

A unification \textsf{X {\ensuremath{=}} Y} is an \emph{assignment} if precisely one of \textsf{X} or \textsf{Y}
is initially instantiated.  Afterwards, both variables will be instantiated.
Assignments are always \textsf{\textbf{det}}.

A unification \textsf{X {\ensuremath{=}} Y} is an \emph{equality test} if both \textsf{X} and \textsf{Y} are
initially instantiated.  Equality tests are always \textsf{\textbf{semidet}}.

\subsection*{Procedure calls}

For a predicate call \textsf{p(X$_{1}$, X$_{2}$, X$_{3}$)}, which procedure of \textsf{p} is executed
depends upon which \textsf{\textbf{mode}} declaration for predicate \textsf{p} best matches the
instantiation states of \textsf{X$_{1}$}, \textsf{X$_{2}$}, and \textsf{X$_{3}$} at the time the call is
executed.  The determinism category of the goal is that of the called
procedure, adjusted for any implied modes (\ie extra unifications added
because some output arguments of the procedure are already instantiated at
the time of the call).

For example, the goal \textsf{phone(``Zoltan'', ZoltansNumber)} is compiled as a call
to the \textsf{(in, out) \textbf{is} \textbf{det}} procedure of \textsf{phone}.  The goal
\textsf{phone(Person, 66540)} is compiled as a call to the \textsf{(out, in) \textbf{is} \textbf{nondet}}
procedure of \textsf{phone}.  The goal \textsf{phone(``Ralph'', 66532)} requires an implied
mode and may be compiled either as \textsf{phone(``Ralph'', Tmp), Tmp {\ensuremath{=}} 66532} or
\textsf{phone(Tmp, 66532), Tmp {\ensuremath{=}} ``Ralph''}, both of which are \textsf{\textbf{semidet}}.

\subsection*{Conjunction}

A sequence of goals separated by commas, \textsf{G$_{1}$, G$_{2}$, G$_{3}$, ...}, is called a
\emph{conjunction}.  The commas are pronounced ``and'' and each subgoal is
called a \emph{conjunct}.

A conjunction can fail if any conjunct can fail.

A conjunction can succeed if every conjunct can succeed.

A conjunction can have multiple solutions if it can succeed
and one or more conjuncts have multiple solutions.

\Note These rules are a conservative (\ie safe) approximation.  For example,
the compiler will conclude that conjunction \textsf{small\_prime(X), X {\ensuremath{=}} 4} is
\textsf{\textbf{semidet}}, even though we can see that this goal has to fail.

\subsection*{Disjunction}

A sequence of goals separated by commas, \textsf{(G$_{1}$ ; G$_{2}$ ; G$_{3}$ ; ...)}, is called a
\emph{disjunction}.  The commas are pronounced ``or'' and each subgoal is
called a \emph{disjunct}.

A disjunction can succeed if any disjunct can succeed.

A disjunction can have multiple solutions if more than one disjunct can
succeed or one or more disjuncts can have multiple solutions.

\Note Switches are a special case.  A switch is a disjunction that
deconstructs a particular variable against a different data constructor in
each disjunct.  If, apart from the deconstructions, every disjunct is \textsf{\textbf{det}},
then the switch is \textsf{\textbf{det}} if the set of deconstructions is exhaustive and
\textsf{\textbf{semidet}} if not.

For example, even though both \textsf{p} and \textsf{q} (below) define switches on \textsf{X},
\textsf{p} is \textsf{\textbf{det}} because its switch is exhaustive, whereas \textsf{q} is \textsf{\textbf{semidet}}
because its switch is not:
\begin{small}

\begin{ptabular}
\column{col13}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col44}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{type} ott {\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}} one ; two ; three.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} p(ott::in, int::out) \textbf{is} \textbf{det}.}}
\nextline
\fromto{col1}{col13}{\textsf{p(X, Y) :{\ensuremath{-}}}}
\fromto{col13}{col44}{\textsf{( X {\ensuremath{=}} one, Y {\ensuremath{=}} 1 ; X {\ensuremath{=}} two,}}
\fromto{col44}{colend}{\textsf{Y {\ensuremath{=}} 2 ; X {\ensuremath{=}} three, Y {\ensuremath{=}} 3 ).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} q(ott::in, int::out) \textbf{is} \textbf{semidet}.}}
\nextline
\fromto{col1}{col13}{\textsf{q(X, Y) :{\ensuremath{-}}}}
\fromto{col13}{col44}{\textsf{( X {\ensuremath{=}} one, Y {\ensuremath{=}} 1 ; X {\ensuremath{=}} three,}}
\fromto{col44}{colend}{\textsf{Y {\ensuremath{=}} 3 ).}}
\nextline
\end{ptabular}

\end{small}

\Note Disjunction binds less tightly than conjunction:
\\\textsf{( G$_{11}$, G$_{12}$ , G$_{13}$ ; G$_{21}$ ; G$_{31}$, G$_{32}$ )}
\\is equivalent to
\\\textsf{( (G$_{11}$, G$_{12}$, G$_{13}$) ; G$_{21}$ ; (G$_{31}$, G$_{32}$) )}.

\Note A definition spanning multiple clauses is equivalent to a
definition using a single clause containing a disjunction.  That is
\begin{small}

\begin{ptabular}
\column{col11}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{col11}{\textsf{p(one,}}
\fromto{col11}{colend}{\textsf{1).}}
\nextline
\fromto{col1}{col11}{\textsf{p(two,}}
\fromto{col11}{colend}{\textsf{2).}}
\nextline
\fromto{col1}{col11}{\textsf{p(three,}}
\fromto{col11}{colend}{\textsf{3).}}
\nextline
\end{ptabular}

\end{small}
is semantically and operationally identical to
\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col13}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{col13}{\textsf{p(X, Y) :{\ensuremath{-}}}}
\fromto{col13}{colend}{\textsf{( X {\ensuremath{=}} one, Y {\ensuremath{=}} 1 ; X {\ensuremath{=}} two, Y {\ensuremath{=}} 2 ; X {\ensuremath{=}} three, Y {\ensuremath{=}} 3 ).}}
\nextline
\end{ptabular}

\end{small}

\Note If any disjunct instantiates a variable that is used outside the
disjunction, then every disjunct in the disjunction must also instantiate
that variable.  That is, the Mercury compiler will report a mode error if a
program contains a disjunction that instantiates \textsf{X} in some disjuncts, but
not others, and \textsf{X} is also needed outside the disjunction.  For instance,
the following is illegal because \textsf{Y}, which appears outside the disjunction,
is instantiated in the first and second disjuncts, but not the third:

\begin{small}

\begin{ptabular}
\column{col13}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} p(number::in, int::out) \textbf{is} \textbf{det}.}}
\nextline
\fromto{col1}{col13}{\textsf{p(X, Y) :{\ensuremath{-}}}}
\fromto{col13}{colend}{\textsf{( X {\ensuremath{=}} one, Y {\ensuremath{=}} 1 ; X {\ensuremath{=}} two, Y {\ensuremath{=}} 2 ; X {\ensuremath{=}} three ).}}
\nextline
\end{ptabular}

\end{small}

\subsection*{Negation}

A goal \textsf{(\textbf{not} G)} is called the \emph{negation} of \textsf{G}.  The negation fails
if \textsf{G} succeeds, and vice versa.  The negation succeeds if \textsf{G} fails and
fails if \textsf{G} succeeds.

\Note \textsf{G} is said to occur inside a \emph{negated context} and is
not allowed to instantiate variables that also occur outside the negation.

\Note Negation binds more tightly than conjunction, hence
\textsf{\textbf{not} G$_{1}$, G$_{2}$, ...} is equivalent to \textsf{(\textbf{not} G$_{1}$), G$_{2}$, ...}.  To negate a
conjunction, put the conjunction in parentheses: \textsf{\textbf{not} (G$_{1}$, G$_{2}$, ...)}

\Note \textsf{X {\ensuremath{\backslash}}{\ensuremath{=}} Y} is syntactic sugar for \textsf{\textbf{not} (X {\ensuremath{=}} Y)}.

\subsection*{If-then-else goals}

The declarative semantics for a goal \textsf{( \textbf{if} Gc \textbf{then} Gt \textbf{else} Ge )} are
identical to those of \textsf{( Gc, Gt ; (\textbf{not} Gc), Ge )}.  The operational
semantics are more efficient, though: if there are no solutions to \textsf{Gc},
the program immediately executes \textsf{Ge}.

If any of \textsf{Gc}, \textsf{Gt}, or \textsf{Ge} can fail then the \textsf{\textbf{if}}-\textsf{\textbf{then}}-\textsf{\textbf{else}} can fail.

If any of \textsf{Gc}, \textsf{Gt}, or \textsf{Ge} can have multiple solutions then the
\textsf{\textbf{if}}-\textsf{\textbf{then}}-\textsf{\textbf{else}} can have multiple solutions.

\Note \textsf{Gc} is not allowed to instantiate variables that are used outside the
\textsf{\textbf{if}}-\textsf{\textbf{then}}-\textsf{\textbf{else}}.  This is because, semantically, \textsf{Gc} appears in a
negated context.  It is all right, however, for \textsf{Gc} to instantiate
variables that are used by \textsf{Gt}.

\Note Execution can backtrack into \textsf{Gc}.  For example,

\textsf{( \textbf{if} small\_prime(X), X {\ensuremath{>}} 2 \textbf{then} Y {\ensuremath{=}} X {\ensuremath{*}} X \textbf{else} Y {\ensuremath{=}} {\ensuremath{-}}1 )}

has solutions \textsf{Y {\ensuremath{=}} 9}, \textsf{Y {\ensuremath{=}} 25}, and \textsf{Y {\ensuremath{=}} 49}.

\Note \textsf{( Gc {\ensuremath{-}}{\ensuremath{>}} Gt ; Ge )} is an alternative, albeit old-fashioned, syntax for
\textsf{( \textbf{if} Gc \textbf{then} Gt \textbf{else} Ge )}.

\section{Procedures and code reordering}

The aim of this section is to give the reader some understanding of code
reordering.  This knowledge is not required to write Mercury programs, but
it can help the programmer understand mode-related error messages from the
compiler.

We will illustrate using the \textsf{append} predicate defined in the \textsf{list}
standard library module.  The declarative semantics of
\textsf{append(Xs, Ys, Zs)} is that the list \textsf{Zs} is the concatentation of lists
\textsf{Xs} and \textsf{Ys}.  So \textsf{append(\char`\[{}1\char`\]{}, \char`\[{}2, 3\char`\]{}, \char`\[{}1, 2, 3\char`\]{})} is true, but
\textsf{append(\char`\[{}2, 3\char`\]{}, \char`\[{}1\char`\]{}, \char`\[{}1, 2, 3\char`\]{})} is not.

\begin{small}

\begin{ptabular}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col43}{@{\ }l@{}}
\column{col27}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col37}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{pred}}}
\fromto{col10}{col27}{\textsf{append(list(T),}}
\fromto{col27}{col37}{\textsf{list(T),}}
\fromto{col37}{colend}{\textsf{list(T)).}}
\nextline
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{mode}}}
\fromto{col10}{col27}{\textsf{append(in,}}
\fromto{col27}{col37}{\textsf{in,}}
\fromto{col37}{col43}{\textsf{out)}}
\fromto{col43}{colend}{\textsf{\textbf{is} \textbf{det}.}}
\nextline
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{mode}}}
\fromto{col10}{col27}{\textsf{append(out,}}
\fromto{col27}{col37}{\textsf{out,}}
\fromto{col37}{col43}{\textsf{in)}}
\fromto{col43}{colend}{\textsf{\textbf{is} \textbf{multi}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{append(Xs, Ys, Zs) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{(}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{colend}{\textsf{Xs {\ensuremath{=}} \char`\[{}\char`\]{}, Zs {\ensuremath{=}} Ys}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{;}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{Xs {\ensuremath{=}} \char`\[{}X $|$ Xs$_{0}$\char`\]{}, append(Xs$_{0}$, Ys, Zs$_{0}$), Zs {\ensuremath{=}} \char`\[{}X $|$ Zs$_{0}$\char`\]{}}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}

This code needs no reordering for the \textsf{(in, in, out) \textbf{is} \textbf{det}} mode, where
\textsf{Xs} and \textsf{Ys} start off instantiated and \textsf{Zs} starts off uninstantiated.
The first disjunct works like this:

\begin{tabular}{lp{0.3\linewidth}l}
1 & \textsf{Xs {\ensuremath{=}} \char`\[{}\char`\]{}} & Deconstruct \textsf{Xs}\\
2 & \textsf{Zs {\ensuremath{=}} Ys} & Assign \textsf{Zs}\\
\end{tabular}

and the second disjunct works like this:

\begin{tabular}{lp{0.3\linewidth}p{0.6\linewidth}}
1 & \textsf{Xs {\ensuremath{=}} \char`\[{}X $|$ Xs$_{0}$\char`\]{}} & Deconstruct \textsf{Xs}, instantiating \textsf{X} and \textsf{Xs$_{0}$}\\
2 & \textsf{append(Xs$_{0}$, Ys, Zs$_{0}$)} & Call the \textsf{(in, in, out)} procedure, instantiating
\textsf{Zs$_{0}$}\\
3 & \textsf{Zs {\ensuremath{=}} \char`\[{}X $|$ Zs$_{0}$\char`\]{}} & Construct \textsf{Zs}\\
\end{tabular}

Because each disjunct deconstructs \textsf{Xs} in a different way, this disjunction
is a switch.  Because the switch is exhaustive, and the other goals in each
disjunct are \textsf{\textbf{det}}, the switch as a whole is \textsf{\textbf{det}}.

The \textsf{(out, out, in) \textbf{is} \textbf{multi}} mode, where only \textsf{Zs} is initially
instantiated, does require some reordering in order to ensure that every
variable is instantiated before it is needed.  The first disjunct becomes

\begin{tabular}{lp{0.3\linewidth}l}
1 & \textsf{Xs {\ensuremath{=}} \char`\[{}\char`\]{}} & Construct \textsf{Xs}\\
2 & \textsf{Zs {\ensuremath{=}} Ys} & Assign \textsf{Ys}\\
\end{tabular}

and the second disjunct becomes

\begin{tabular}{lp{0.3\linewidth}p{0.6\linewidth}}
1 & \textsf{Zs {\ensuremath{=}} \char`\[{}X $|$ Zs$_{0}$\char`\]{}} & Deconstruct \textsf{Zs}, instantiating \textsf{X} and \textsf{Zs$_{0}$}\\
2 & \textsf{append(Xs$_{0}$, Ys, Zs$_{0}$)} & Call the \textsf{(out, out, in)} procedure, instantiating
\textsf{Xs$_{0}$} and \textsf{Ys}\\
3 & \textsf{Xs {\ensuremath{=}} \char`\[{}X $|$ Xs$_{0}$\char`\]{}} & Construct \textsf{Xs}\\
\end{tabular}

Since this disjunction is not a switch and the first disjunct always leads
to a solution, the disjunction as a whole is \textsf{\textbf{multi}} in this case.

\Note The Mercury compiler reorders code as little as possible.  However,
programmers should not write code that depends upon any particular order of
evaluation --- code can also be reordered by various optimizations!  In
particular, it is a bad idea to write something like
\textsf{( \textbf{if} X {\ensuremath{\backslash}}{\ensuremath{=}} 0, Z {\ensuremath{=}} Y / X \textbf{then} ... \textbf{else} ... )}, assuming that the test for \textsf{X}
being non-zero will guarantee that this code cannot lead to a
division-by-zero error at run-time.  It is certainly possible that the test
and the division may be compiled the other way around.

\section{Insts and subtypes}

So far we have only talked about variables going from being uninstantiated
to being instantiated.  It turns out to be useful to also keep track of the
possible values a variable can have when it is instantiated.  Mercury uses
\textsf{\textbf{inst}}s for this purpose.  An \textsf{\textbf{inst}} represents the possible
instantiantiation states of a variable at a particular point in a program.

The most basic \textsf{\textbf{inst}}s are \textsf{free}, meaning a variable is uninstantiated, and
\textsf{ground}, meaning a variable is instantiated with some unknown value of the
appropriate type.

The built-in \textsf{\textbf{mode}}s \textsf{in} and \textsf{out} are defined using the following syntax:

\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col14}{@{\ }l@{}}
\column{col26}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{col14}{\textsf{:{\ensuremath{-}} \textbf{mode} in}}
\fromto{col14}{col26}{\textsf{{\ensuremath{=}}{\ensuremath{=}} (ground}}
\fromto{col26}{colend}{\textsf{{\ensuremath{>}}{\ensuremath{>}} ground).}}
\nextline
\fromto{col1}{col14}{\textsf{:{\ensuremath{-}} \textbf{mode} out}}
\fromto{col14}{col26}{\textsf{{\ensuremath{=}}{\ensuremath{=}} (free}}
\fromto{col26}{colend}{\textsf{{\ensuremath{>}}{\ensuremath{>}} ground).}}
\nextline
\end{ptabular}

\end{small}

That is, an \textsf{in} mode argument of a goal must be \textsf{ground} (\ie be
instantiated with some value) before the goal is executed and will also be
\textsf{ground} afterwards, while an \textsf{out} mode argument must be \textsf{free} (\ie not
instantiated) before the goal is executed, but will be \textsf{ground} afterwards.

\Note If a goal fails or backtracks then the \textsf{\textbf{inst}}s of its arguments stay
the same as they were before the goal was tried.

\subsection*{Specialised insts}

It is occasionally useful to define new \textsf{\textbf{inst}}s matching only subsets of
possible values that a variable might have.  Consider the following:

\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col36}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col10}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{inst} non\_empty\_list {\ensuremath{=}}{\ensuremath{=}} bound(\char`\[{}ground $|$ ground\char`\]{}).}}
\nextline
\nextline
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{pred}}}
\fromto{col10}{colend}{\textsf{head(list(T), T).}}
\nextline
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{mode}}}
\fromto{col10}{col36}{\textsf{head(in,}}
\fromto{col36}{colend}{\textsf{out) \textbf{is} \textbf{semidet}.}}
\nextline
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{mode}}}
\fromto{col10}{col36}{\textsf{head(in(non\_empty\_list),}}
\fromto{col36}{colend}{\textsf{out) \textbf{is} \textbf{det}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{head(Xs, X) :{\ensuremath{-}} Xs {\ensuremath{=}} \char`\[{}X $|$ \_\char`\]{}.}}
\nextline
\end{ptabular}

\end{small}

The \textsf{\textbf{inst}} declaration defines \textsf{non\_empty\_list} to mean ``bound to the list
data constructor \textsf{\char`\[{}$|$\char`\]{}} whose first argument has inst \textsf{ground} and whose
second argument has inst \textsf{ground}''.

The first mode for \textsf{head} tells us that if all we know about the first
argument is that it is \textsf{ground} (\ie it could be bound to any value of type
\textsf{list(T)}, including \textsf{\char`\[{}\char`\]{}}) then a call to \textsf{head} is semidet.

The second mode for \textsf{head} says that if we know the first argument is a
non-empty list (\ie whatever value it has, it's top-most data constructor
must be \textsf{\char`\[{}$|$\char`\]{}} with two \textsf{ground} arguments) then a call to \textsf{head} is
guaranteed to succeed.

The second \textsf{\textbf{mode}} declaration uses the built-in parameterised form of the
\textsf{in} argument mode, which is defined like this:

\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{mode} in(I) {\ensuremath{=}}{\ensuremath{=}} (I {\ensuremath{>}}{\ensuremath{>}} I).}}
\nextline
\end{ptabular}

\end{small}

where \textsf{I} is an \textsf{\textbf{inst}} parameter.  \textsf{in(non\_empty\_list)} is therefore
equivalent to writing \textsf{(non\_empty\_list {\ensuremath{>}}{\ensuremath{>}} non\_empty\_list)}.  There is also a
built-in parameterised \textsf{out} argument mode, defined thus:

\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{mode} out(I) {\ensuremath{=}}{\ensuremath{=}} (free {\ensuremath{>}}{\ensuremath{>}} I).}}
\nextline
\end{ptabular}

\end{small}

When compiling the procedure for the second mode of \textsf{head}, the Mercury
compiler uses the information about the inst of the first argument, \textsf{Xs}, to
infer that the goal \textsf{Xs {\ensuremath{=}} \char`\[{}X $|$ \_\char`\]{}} must (a) be a deconstruction and (b) must
succeed because whatever value \textsf{Xs} has matches the pattern \textsf{\char`\[{}\_ $|$ \_\char`\]{}}.

\Note A value with a \textsf{bound(...)} \textsf{\textbf{inst}} can always be used in a context
where a \textsf{ground} value is expected, but not the other way around.

\XXX{Mention the alternative \textsf{\textbf{inst}} definition syntax.}

\subsection*{Recursively defined insts}

It is possible to describe quite complicated instantiation states.  The
following \textsf{\textbf{inst}}s, for instance, describe lists of even and odd lengths
respectively:

\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col27}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{col27}{\textsf{:{\ensuremath{-}} \textbf{inst} even\_length\_list}}
\fromto{col27}{colend}{\textsf{{\ensuremath{=}}{\ensuremath{=}} bound(\char`\[{}\char`\]{} ; \char`\[{}ground $|$ odd\_length\_list\char`\]{}).}}
\nextline
\fromto{col1}{col27}{\textsf{:{\ensuremath{-}} \textbf{inst} odd\_length\_list}}
\fromto{col27}{colend}{\textsf{{\ensuremath{=}}{\ensuremath{=}} bound(\char`\[{}ground $|$ even\_length\_list\char`\]{}).}}
\nextline
\end{ptabular}

\end{small}

The first \textsf{\textbf{inst}} declaration defines \textsf{even\_length\_list} to mean ``bound
\emph{either} to \textsf{\char`\[{}\char`\]{}} \emph{or} to \textsf{\char`\[{}$|$\char`\]{}} with two arguments, the first
having \textsf{\textbf{inst}} \textsf{ground} and the second having \textsf{\textbf{inst}} \textsf{odd\_length\_list}
(multiple possibilities in a \textsf{bound} expression are separated by
semicolons).

The second \textsf{\textbf{inst}} declaration defines \textsf{odd\_length\_list} to mean ``bound to
\textsf{\char`\[{}$|$\char`\]{}} with two arguments, the first having \textsf{\textbf{inst}} \textsf{ground} and the second
having inst \textsf{even\_length\_list}.''

\subsection*{Partial instantiation}

A partially instantiated value is one whose \textsf{\textbf{inst}} is \textsf{bound(...)} where
the \textsf{...} part contains \textsf{free} sub-insts, either directly or indirectly.

Partial instantiation is not currently supported for several reasons,
including the difficulty of analysing such code, the difficulty of
maintaining such code, and the difficulty of compiling such code
efficiently.

\section{Uniqueness}

A \textsf{bound(...)} inst is said to be \emph{shared} --- that is, it corresponds
to a value that may be referred to, directly or indirectly, by more than one
variable at a given point in the program.

Mercury has a special inst, \textsf{unique}, which is like \textsf{ground}, but it means
that there is precisely one reference to the \textsf{unique} data at this point in
the program.  The counterpart to \textsf{unique}, is \textsf{clobbered}.  A variable with
\textsf{\textbf{inst}} \textsf{clobbered} may never be used again (\eg because the value it refers
to is now out-of-date or has been overwritten with something else).

The most common use of uniqueness is for managing IO.  All the IO operations
defined in the \textsf{io} standard library module include two arguments of type
\textsf{io}, with modes \textsf{di} and \textsf{uo} respectively.  \textsf{di} stands for ``destructive
input'' and \textsf{uo} stands for ``unique output''.  These \textsf{\textbf{mode}}s are built-in
and defined thus:

\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col13}{@{\ }l@{}}
\column{col25}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{col13}{\textsf{:{\ensuremath{-}} \textbf{mode} di}}
\fromto{col13}{col25}{\textsf{{\ensuremath{=}}{\ensuremath{=}} (unique}}
\fromto{col25}{colend}{\textsf{{\ensuremath{>}}{\ensuremath{>}} clobbered).}}
\nextline
\fromto{col1}{col13}{\textsf{:{\ensuremath{-}} \textbf{mode} uo}}
\fromto{col13}{col25}{\textsf{{\ensuremath{=}}{\ensuremath{=}} (free}}
\fromto{col25}{colend}{\textsf{{\ensuremath{>}}{\ensuremath{>}} unique).}}
\nextline
\end{ptabular}

\end{small}

To illustrate, consider these \textsf{\textbf{pred}} declarations taken from the \textsf{io}
module:

\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} io.write\_string(string::in, io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} io.write\_int(int::in, io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} io.nl(io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\end{ptabular}

\end{small}

and the following code snippet:

\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.write\_string(``The meaning of life \textbf{is} '', IO$_{0}$, IO$_{1}$),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_int(42, IO$_{1}$, IO$_{2}$),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.nl(IO$_{2}$, IO$_{3}$)}}
\nextline
\end{ptabular}

\end{small}

The \textsf{io} type arguments denote ``states of the world''.  These \textsf{io} states
are updated when IO actions are performed.  One can never go back to an
earlier state (you can't unplay a piece of music or unprint a document),
so each IO action clobbers the \textsf{io} state passed to it and produces
and new \textsf{io} state as its result.  Similarly, because one cannot copy the
state of the world, \textsf{io} states have to be unique.  These constraints ensure
that the above code snippet executes in the expected order --- that is,
first the string \textsf{``The meaning of life \textbf{is} ''} will be printed
(clobbering \textsf{IO$_{0}$} and producing \textsf{IO$_{1}$}), then the number \textsf{42}
(clobbering \textsf{IO$_{1}$} and producing \textsf{IO$_{2}$}), and finally a newline (clobbering
\textsf{IO$_{2}$} and producing \textsf{IO$_{3}$}).

Say we were to accidentally reuse \textsf{IO$_{0}$} in the second goal:

\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.write\_string(``The meaning of life \textbf{is} '', IO$_{0}$, IO$_{1}$),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_int(42, IO$_{0}$, IO$_{2}$),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.nl(IO$_{2}$, IO$_{3}$)}}
\nextline
\end{ptabular}

\end{small}

The Mercury compiler will report the following error
(line 27 in file \textsf{foo.m} is the call to \textsf{io.write\_string}):

\begin{small}

\begin{ptabular}
\column{colend}{@{\ }l@{}}
\column{col16}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\fromto{col1}{col16}{\textsf{foo.m:027: In}}
\fromto{col16}{colend}{\textsf{clause for `main(di, uo)':}}
\nextline
\fromto{col1}{col16}{\textsf{foo.m:027:}}
\fromto{col16}{colend}{\textsf{in argument 2 of call to predicate `io.write\_string/3':}}
\nextline
\fromto{col1}{col16}{\textsf{foo.m:027:}}
\fromto{col16}{colend}{\textsf{unique{\ensuremath{-}}\textbf{mode} error: the called procedure would clobber}}
\nextline
\fromto{col1}{col16}{\textsf{foo.m:027:}}
\fromto{col16}{colend}{\textsf{its argument, but variable `IO$_{0}$' \textbf{is} still live.}}
\nextline
\end{ptabular}

\end{small}

\Note Procedures that can clobber arguments must have determinism category
\textsf{\textbf{det}} or \textsf{\textbf{cc\_multi}}.  They must always succeed and produce a single result.
The reason for this is that once an argument is clobbered, which could
happen at any point during the execution of the procedure, there is no way
of un-clobbering it on failure or backtracking.  Consequently it is also an
error for code to backtrack into such procedures.  For the rare cases where
one needs to do such things, the reader is referred to the section on
backtrackable destructive update in the Mercury reference manual which
discusses ``mostly uniqueness''.

Other modules in the standard library that use uniqueness are \textsf{array} and
\textsf{store}.  The \textsf{array} module implements arrays with $O(1)$ look-up and set
operations.  It achieves this by using destructive update for the array set
operation.  This is quite safe because arrays are unique: the `old' version
of the array is clobbered by the update operation so it can never
be referred to again; the `new' version of the array is simply the updated
`old' version.  The \textsf{store} module allows one to construct safe,
pointer-based structures.  Pointer referents can be accessed and updated in
$O(1)$ time by using the same technique as for arrays.  Chapter XXX
describes these modules in more detail.

\section{Higher-order modes}

\XXX{Fill this out.}

\section{Committed-choice nondeterminism}

\XXX{Fill this out.}

The \textsf{\textbf{cc\_nondet}} and \textsf{\textbf{cc\_multi}} modes.  There may be multiple solutions to a
cc predicate, but you will only get one of them.

The compiler will report an error if a program can backtrack into a
committed-choice goal: all goals following a committed-choice goal must be
\emph{guaranteed} to succeed.  Programming under this restriction is quite
burdensome.

If all solutions to a committed-choice predicate are equivalent, in the
sense that, no matter which solution you get, the observable behaviour of
your program will be the same, then you can use the built-in function
\textsf{promise\_only\_solution} to escape from the committed-choice context.


\end{document}
