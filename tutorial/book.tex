%------------------------------------------------------------------------------%
% book.tex
% Ralph Becket <rafe@cs.mu.oz.au>
% Mon Jul 15 12:11:53 EST 2002
% vim: ft=tex ff=unix ts=4 sw=4 et wm=8 tw=0
%
%------------------------------------------------------------------------------%



%- Preamble -------------------------------------------------------------------%

\documentclass[a4paper,11pt,notitlepage,onecolumn]{book}
    %
    % [options]
    %   (10|11|12)pt            -- (default 10pt)
    %   (a4|letter)paper        -- (default letterpaper)
    %   fleqn                   -- (default centred) left-align formulae as
    %   leqno                   -- (default right) number formulae on the left
    %   [no]titlepage           -- [do not] start new page after the title
    %   (one|two)column         -- (default onecolumn)
    %   (one|two)side
    %   open(right|any)         -- open chapters on (right|any) pages only
    % {class}
    %   (article|report|book|slides)
    %                           -- consider FoilTeX instead of slides

\usepackage{polytable}

\pagestyle{headings}
    %
    % {style}
    %   (plain|headings|empty)  -- (default plain)
    %                           -- use \thispagestyle{} for new styles

\input{defs}

%- Start of Document ----------------------------------------------------------%

\begin{document}

\setlength{\parindent}{0pt}
\setlength{\parskip}{\baselineskip}
% \setlength{\hoffset}{}        % -- left margin is this + 1in
% \setlength{\voffset}{}        % -- top margin is this + 1in
% \setlength{\textheight}{}
% \setlength{\textwidth}{}
% \setlength{\marginparwidth}{}
    %
    % -- or can use \addtolength{argument}{length}
    % -- or can use \settoheight{argument}{text}
    % -- or can use \settodepth{argument}{text}
    % -- or can use \settowidth{argument}{text}

\title{The Art of Mercury}
\author{Ralph Becket \\ \texttt{\small rafe@cs.mu.oz.au}}
\date{15 October 2001}

% \maketitle

% \begin{abstract}
%
% ...
%
% \end{abstract}

%\tableofcontents

%- Body -----------------------------------------------------------------------%

    % \text(rm|tt|sf|bf|it|sc|sl|up|md|normal){} \emph{}

    % \math(rm|tt|sf|bf|it|sc|sl|up|md|normal){}

    % \tiny \scriptsize \footnotesize \small \normalsize
    % \large \Large \LARGE \huge \Huge
    %                           -- also work as environments

    % ~                         -- small, fixed, nonbreaking space
    % \hspace{size}             -- soft space (may be lost at SOL or EOL)
    % \hspace*{size}            -- hard space
    %                           -- size may be \stretch{factor}
    % \hfill                    -- same as \hspace{\fill}

    % \vspace{size}             -- soft space (may be lost at TOP or BOP)
    % \vspace*{size}            -- hard space
    %                           -- size may be \stretch{factor}
    %                           --  of \smallskip or \bigskip

    % \\                        -- linebreak
    % \\*                       -- linebreak but prohibit page break
    % \newpage

    % \rule[lift]{width}{height}

    % \parbox[(c|t|b)]{width}{text}
    % \begin{minipage}[(c|t|b)]{width} text \end{minipage}
    % \mbox{text}               -- prevents word breaking

    % \begin{(flushleft|flushright|center|quote|verse)}
    % text
    % \end{(flushleft|flushright|center|quote|verse)}

    % \verb@verbatim text@
    % \begin{verbatim}
    % verbatim text
    % \end{verbatim}

    % \begin{tabular}{(l|r|c|p{width}|<bar>|@{colsep})...}
    % datum & datum & ... \
    % datum & datum & ... \
    % \hline
    % datum & datum & ... \
    % \cline{1-2}   & ... \
    % \multicolumn{2}{(l|c|r)}{wide datum} & ... \
    % \end{tabular}

    % \begin{(figure|table)}[[!](h|t|b|p)...]
    % ...
    % \caption{caption text}
    % \end{(figure|table)}

    % \label{marker}            -- set a marker
    % \ref{marker}              -- section containing marker
    % \pageref{marker}          -- page number of marker

    % $ ... $                   -- inline mathematics
    % \[ ... \]                 -- display mathematics
    % \begin{equation}          -- align* suppresses numbering
    % ...
    % \end{equation}
    % \begin{array}{...}        -- as tabular
    % ...
    % \end{array}
    % \begin{eqnarray}          -- as {array}{rcl} but with numbering
    % ...                       -- use \nonumber to suppress numbering of a row
    % \end{eqnarray}
    % \, \; \<spc> \quad \qquad -- math-mode spacing
    % \(over|under)line{...}
    % \(over|under)brace{...}_{...}
    % \wide(tilde|hat)
    % \overrightarrow
    % \frac{top}{bottom}
    % {... \choose ...}         -- adds parentheses
    % {... \atop ...}           -- no parentheses
    % \stackrel{topsym}{linesym}
    % \left<brasym> ... \right<ketsym>
    %                           -- use \right. for no <keysym>
    %                           -- empty lines etc. forbidden in math mode

% \include{}
    %
    % -- \includeonly takes a list of file names and filters any \includes
    %    (can only appear in the preamble.)
    % -- \include takes a single file name, starts a new page
    % -- \input does not start a new page
    % -- omit the .tex suffix from the file names

\newcommand{\polytexopenbrace}%
{\{}
\newcommand{\polytexclosebrace}%
{\}}
\newcommand{\polytexampersand}%
{\&}
%%subst %.*                      \textrm{&}
%%subst --->                     $\longrightarrow$
%%subst -->                      $\rightarrow$
%%subst ->                       $\rightarrow$
%%subst =<                       $\leq$
%%subst >=                       $\geq$
%%subst <=>                      $\Leftrightarrow$
%%subst <=                       $\Leftarrow$
%%subst =>                       $\Rightarrow$
%%subst <<                       $\ll$
%%subst >>                       $\gg$

% \setcounter{chapter}{-1}
% %include 00-introduction.polytex
\setcounter{chapter}{0}
% vim: ft=tex ff=unix ts=4 sw=4 et tw=76

\chapter{Mercury By Example}

Last edited Jan 8 16:13

This chapter aims to convey through examples a basic feeling for how
Mercury works.  Because this is the first chapter, we may gloss over some
fine detail and allow ourselves a certain latitude in precision, but this
will not worry us as we will correct these deficiencies in later chapters.
The approach taken here is to start by presenting the ``obvious'' solution
to a problem and then introduce features of Mercury that allow for more
elegant or efficient programs.



\section{Hello, World!}

It is slightly unfortunate that the ``Hello, World!'' program introduces
no less than three advanced Mercury concepts, but since tradition
dictates that tutorial texts start with ``Hello, World!'' we'll just
have to jump straight in with the knowledge that things will get easier
thereafter.

We'll start by presenting the complete program which we'll assume we've
typed into a file called \textsf{hello.m}:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{module} hello.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{interface}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} io.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} main(io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{implementation}.}}
\nextline
\fromto{col1}{colend}{\textsf{main(IOState\_in, IOState\_out) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.write\_string(``Hello, World!{\ensuremath{\backslash}}n'', IOState\_in, IOState\_out).}}
\nextline
\end{ptabular}

\end{small}
Let's go through this line by line.
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{module} hello.}}
\nextline
\end{ptabular}

\end{small}
Every module must start with a declaration like this giving the name of the
module; the Mercury compiler will expect a module called \textsf{hello} in
a file called \textsf{hello.m}.
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{interface}.}}
\nextline
\end{ptabular}

\end{small}
An \textsf{\textbf{interface}} declaration introduces the part of module describing the
things we are going to export (\ie allow users of the module to see).
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} io.}}
\nextline
\end{ptabular}

\end{small}
This \textsf{\textbf{import\_module}} declaration says that we need to use some of the names
exported by the \textsf{io} module, which is part of the standard Mercury library.
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} main(io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\end{ptabular}

\end{small}
This says that we are going to define a \emph{predicate} called \textsf{main} with
two arguments of type \textsf{io} (which happens to be defined in the \textsf{io}
module), the first of which is a \emph{destructive input} argument, and the
second of which is a \emph{unique output} argument; the \textsf{\textbf{is} \textbf{det}} part
tells us that \textsf{main} is a \emph{deterministic} predicate --- that is,
\textsf{main} always succeeds and will always compute the same output given the
same input (we will see later that some Mercury predicates can fail and
some can have more than one solution).

Every Mercury program needs to export a predicate called \textsf{main}, which the
compiler takes as the starting point for the Mercury program as a whole.
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{implementation}.}}
\nextline
\end{ptabular}

\end{small}
Everything after an \textsf{\textbf{implementation}} declaration is considered private
implementation detail not visible to other users of the module.
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(IOState\_in, IOState\_out) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.write\_string(``Hello, World!{\ensuremath{\backslash}}n'', IOState\_in, IOState\_out).}}
\nextline
\end{ptabular}

\end{small}
Finally, we have a \emph{clause} defining \textsf{main}.  A clause comprises a
\emph{head} and \emph{body} separated by a \textsf{:{\ensuremath{-}}} symbol.  The \emph{head} of
this clause tells us that this is a definition for \textsf{main} and names its two
arguments \textsf{IOState\_in} and \textsf{IOState\_out}.  The body of the clause, which is executed
when \textsf{main} is called, consists of a single \emph{goal} calling
\textsf{io.write\_string} (\ie the \textsf{write\_string} predicate defined in the \textsf{io}
module) with a message (Mercury interprets the \textsf{{\ensuremath{\backslash}}n} sequence in the string
argument as a literal newline character) and the two \textsf{IOState} arguments.

Program variables in Mercury always start with a capital letter or
underscore, while names of predicates, types, modules and so forth do not.

We can compile and run \textsf{hello.m} as follows (\textsf{\char`\${}} indicates the command line
prompt):
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{\char`\${} mmc {\ensuremath{-}}{\ensuremath{-}}make hello}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/int3s/hello.int3}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/cs/hello.c}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/os/hello.o}}
\nextline
\fromto{col1}{colend}{\textsf{Making hello}}
\nextline
\fromto{col1}{colend}{\textsf{\char`\${} ./hello}}
\nextline
\fromto{col1}{colend}{\textsf{Hello, World!}}
\nextline
\end{ptabular}

\end{small}
Et voila!  (By default, \textsf{mmc {\ensuremath{-}}{\ensuremath{-}}make} will construct a local \textsf{Mercury}
directory, if necessary, to hold intermediate files generated during
compilation.)

At this point the reader is probably wondering about the meaning of the \textsf{io}
type arguments \textsf{IOState\_in} and \textsf{IOState\_out}, and the strange \textsf{di} and \textsf{uo}
\emph{argument modes}.  The short answer is that every predicate that
performs I/O has to have an \textsf{io} type input argument describing
the state of the world at the time the predicate is called and an \textsf{io} type
output argument describing the state of the world after the call.  This is
how Mercury allows programs to communicate with the outside world without
hidden side effects which would compromise its mathematical integrity.

Because it doesn't make much sense to try reusing an old \textsf{io} state --- you
can't go back in time
--- \textsf{io} states are \emph{unique}.
This is where the \textsf{di} and \textsf{uo} argument modes come in: they are just like
the ordinary \textsf{in} and \textsf{out} argument modes we'll meet in the next section,
except that they also specify uniqueness.  The Mercury compiler will not
allow programs to copy unique values or reuse dead ones:
there is only ever \emph{one} ``live'' I/O state at a time in a running
Mercury program.  This property guarantees that I/O operations occur
in the intended order.

So what if we want to do more than one I/O operation?  In this case we have
to give names to each of the intermediate \textsf{io} states:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(IOState\_in, IOState\_out) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.write\_string(``Hello, '', IOState\_in, IOState\_1),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_string(``World!'', IOState\_1, IOState\_2),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.nl(IOState\_2, IOState\_out).}}
\nextline
\end{ptabular}

\end{small}
The first call to \textsf{io.write\_string} takes \textsf{IOState\_in} as an input, destroys it
in the process of writing its string argument, and produces \textsf{IOState\_1} as its
result.  Then the second call to \textsf{io.write\_string} destroys \textsf{IOState\_1}
and produces \textsf{IOState\_2}.  Finally, \textsf{io.nl} (which just writes out a
newline), destroys \textsf{IOState\_2} and returns \textsf{IOState\_out}, which is the
result of the call to \textsf{main}.

Naming all these intermediate states quickly becomes tedious, so Mercury
provides us with syntactic sugar in the form of \emph{state variables}:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.write\_string(``Hello, '', !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_string(``World!'', !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.nl(!IO).}}
\nextline
\end{ptabular}

\end{small}
This code is transformed by the compiler into something equivalent to the
preceding example: each occurrence of the \textsf{!IO} state variable actually
stands for two normal variables, which are given intermediate names in the
``obvious'' way (the full details of the state variable transformation can
be found in the Mercury Reference Manual).  Note that there is no special
significance in the name \textsf{IO}, which we merely use by convention.

\subsection*{Points to remember}

\begin{itemize}
\item A module starts with a \textsf{\textbf{module}} declaration and is followed by an
\textsf{\textbf{interface}} section and an \textsf{\textbf{implementation}} section.
\item The interface section declares the things that are exported by the
module.
\item All declarations start with a \textsf{:{\ensuremath{-}}} symbol.
\item Declarations and clauses always end with a full stop.
\item We have to import a module before we can use things exported by that
module.
\item Every Mercury program must export a predicate called \textsf{main}.
\item Predicates are defined by clauses, which go in the implementation
section.
\item Variable names start with a capital letter; names of modules, types,
predicates and so forth start with a lower-case letter or use symbols (\eg
the \textsf{int} module defines \textsf{{\ensuremath{+}}} to mean integer addition).
\item Every predicate that performs I/O must have an \textsf{io::di} argument and an
\textsf{io::uo} argument and must be deterministic.
\item We use state variables to avoid having to explicitly name every \textsf{io}
state.
\end{itemize}





\newpage





\section{The Fibonacci numbers}

Another great computer science tradition is defining a
function to calculate numbers in the Fibonacci series:
1 1 2 3 5 8 13 21 34\ldots where, apart from the leading 1s, each number is
the sum of the preceding two.

As before, we'll start by showing a complete program and then look at the
interesting parts in more detail.
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col14}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col8}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{module} fib.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{interface}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} io.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} main(io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{implementation}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} int.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} fib(int::in, int::out) \textbf{is} \textbf{det}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{fib(N, X) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{col8}{\textsf{(}}
\fromto{col8}{col14}{\textsf{\textbf{if}}}
\fromto{col14}{colend}{\textsf{N {\ensuremath{=}}{\ensuremath{<}} 2}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{col14}{\textsf{\textbf{then}}}
\fromto{col14}{colend}{\textsf{X {\ensuremath{=}} 1}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{col14}{\textsf{\textbf{else}}}
\fromto{col14}{colend}{\textsf{fib(N {\ensuremath{-}} 1, A), fib(N {\ensuremath{-}} 2, B), X {\ensuremath{=}} A {\ensuremath{+}} B}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{fib(17, X),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_string(``fib(17, '', !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_int(X, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_string(``){\ensuremath{\backslash}}n'', !IO).}}
\nextline
\end{ptabular}

\end{small}
Building and running \textsf{fib.m}, we find that\ldots
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{\char`\${} mmc {\ensuremath{-}}{\ensuremath{-}}make fib}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/int3s/fib.int3}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/cs/fib.c}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/os/fib.o}}
\nextline
\fromto{col1}{colend}{\textsf{Making fib}}
\nextline
\fromto{col1}{colend}{\textsf{\char`\${} ./fib}}
\nextline
\fromto{col1}{colend}{\textsf{fib(17, 1597)}}
\nextline
\end{ptabular}

\end{small}

The first thing to note is the \textsf{\textbf{import\_module}} declaration at the start
of the implementation section.  We need to import the \textsf{int} module from the
Mercury standard library because it defines all the operations on integers,
such as addition and comparison.  We import it in the implementation
section rather than the interface section because that's the only place we
refer to names defined in the \textsf{int} module.

Next the declaration
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} fib(int::in, int::out) \textbf{is} \textbf{det}.}}
\nextline
\end{ptabular}

\end{small}
says that we are going to define a predicate \textsf{fib} taking two \textsf{int}
arguments, an input and an output, which always succeeds and always
computes the same output given the same input.
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col14}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col8}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{fib(N, X) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{col8}{\textsf{(}}
\fromto{col8}{col14}{\textsf{\textbf{if}}}
\fromto{col14}{colend}{\textsf{N {\ensuremath{=}}{\ensuremath{<}} 2}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{col14}{\textsf{\textbf{then}}}
\fromto{col14}{colend}{\textsf{X {\ensuremath{=}} 1}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{col14}{\textsf{\textbf{else}}}
\fromto{col14}{colend}{\textsf{fib(N {\ensuremath{-}} 1, A), fib(N {\ensuremath{-}} 2, B), X {\ensuremath{=}} A {\ensuremath{+}} B}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
The body of the \textsf{fib} definition uses an \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} goal to decide what
to do; the \textsf{\textbf{else}} part is not optional; and the whole thing appears in
parentheses.  The condition \textsf{N {\ensuremath{=}}{\ensuremath{<}} 2} succeeds if \textsf{N} is less than or equal
to 2 and \emph{fails} otherwise (we'll learn more about \textsf{\textbf{semidet}} predicates
like \textsf{{\ensuremath{=}}{\ensuremath{<}}} in later examples).  If \textsf{N {\ensuremath{=}}{\ensuremath{<}} 2} then the
\emph{unification} \textsf{X {\ensuremath{=}} 1} is executed.  Otherwise \textsf{fib} is called twice to
compute the preceding two Fibonacci numbers in \textsf{A} and \textsf{B}, and \textsf{X}
is unified with their sum (note that we don't need to declare \textsf{A} and \textsf{B}
anywhere).

Finally we have
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{fib(17, X),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_string(``fib(17, '', !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_int(X, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_string(``){\ensuremath{\backslash}}n'', !IO).}}
\nextline
\end{ptabular}

\end{small}
which calls \textsf{fib(17, X)}, unifying \textsf{X} with the result of computing the 17th
Fibonacci number, then writes out the answer.

Now, just as \textsf{N {\ensuremath{-}} 1} computes \textsf{N} minus 1 and \textsf{A {\ensuremath{+}} B} computes
the sum of \textsf{A} and \textsf{B}, it is possible to define \textsf{fib} so
that \textsf{fib(N)} computes the \textsf{N}th Fibonacci number:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col14}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col8}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{func} fib(int) {\ensuremath{=}} int.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{fib(N) {\ensuremath{=}} X :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{col8}{\textsf{(}}
\fromto{col8}{col14}{\textsf{\textbf{if}}}
\fromto{col14}{colend}{\textsf{N {\ensuremath{=}}{\ensuremath{<}} 2}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{col14}{\textsf{\textbf{then}}}
\fromto{col14}{colend}{\textsf{X {\ensuremath{=}} 1}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{col14}{\textsf{\textbf{else}}}
\fromto{col14}{colend}{\textsf{X {\ensuremath{=}} fib(N {\ensuremath{-}} 1) {\ensuremath{+}} fib(N {\ensuremath{-}} 2)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
The \textsf{\textbf{func}} declaration introduces \textsf{fib} as a \emph{function} with an \textsf{int}
argument computing an \textsf{int} result.  Mercury assumes that the input
arguments to a function have mode \textsf{in}, the result has mode \textsf{out}, and
that the function as a whole \textsf{\textbf{is} \textbf{det}}.

Functions are also defined using clauses, the only difference being that the
head of a function clause takes the form \emph{FuncCall}\textsf{{\ensuremath{=}}}\emph{Result}.

Having redefined \textsf{fib} as a function, we also have to change how it is
called in \textsf{main}:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.write\_string(``fib(17) {\ensuremath{=}} '', !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.write\_int(fib(17), !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.nl(!IO).}}
\nextline
\end{ptabular}

\end{small}

Here is one last refinement we might like to make to our
definition of \textsf{fib}:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{fib(N) {\ensuremath{=}} ( \textbf{if} N {\ensuremath{=}}{\ensuremath{<}} 2 \textbf{then} 1 \textbf{else} fib(N {\ensuremath{-}} 1) {\ensuremath{+}} fib(N {\ensuremath{-}} 2) ).}}
\nextline
\end{ptabular}

\end{small}
By using an \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} \emph{expression} we can move the entire body
into the head of the clause.  Since the clause now has an empty body,
Mercury requires that we omit the \textsf{:{\ensuremath{-}}} part.

It is worth noting that all three of our definitions are computationally
identical and there is no difference in the code generated by the
Mercury compiler.  Whether to use a predicate or function is largely a
matter of taste; a good rule of thumb is that if a predicate has a single
output argument, and is deterministic, then it is probably better expressed
as a function.

\subsection*{Points to remember}

\begin{itemize}
\item Import modules in the implementation section only if they are only
referred to in the implementation section.
\item Non-unique arguments (typically non-\textsf{io} arguments) normally use the \textsf{in}
and \textsf{out} argument modes.
\item You can use functions to make your code more readable.
\item \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} can be used as a goal and as an expression; it should
appear in parentheses and the \textsf{\textbf{else}} part is mandatory.
\item If a clause of a predicate or a function has an empty body (because
all the computation is described in the head), then the \textsf{:{\ensuremath{-}}} must be omitted.
\end{itemize}





\newpage





\section{Simple input}

We can extend our Fibonacci program to read in \textsf{N} rather than have it
hard-coded by changing the definition of \textsf{main}:
\begin{small}

\begin{ptabular}
\column{col10}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col8}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} list, string.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.read\_line\_as\_string(Result, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{col8}{\textsf{(}}
\fromto{col8}{colend}{\textsf{\textbf{if}}}
\nextline
\fromto{col1}{col10}{\hspace*{2.7em}}
\fromto{col10}{colend}{\textsf{Result {\ensuremath{=}} ok(String),}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{string.to\_int(string.strip(String), N)}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{then}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{io.format(``fib(\%d) {\ensuremath{=}} \%d{\ensuremath{\backslash}}n'', \char`\[{}i(N), i(fib(N))\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{else}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{io.format(``That isn't a number...{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
The \textsf{list} and \textsf{string} standard library modules are imported in the
implementation section because we use them in the definition of \textsf{main} (the
\textsf{io} module has already been imported in the interface section).

\textsf{main} begins by calling \textsf{io.read\_line\_as\_string}, which reads a whole line
of input up to and including the next newline character.  If all goes well
then \textsf{Result} ends up unified to a value \textsf{ok(String)}, where \textsf{String} is the
string of characters read in and \textsf{ok} is a ``tag'' known as a \emph{data
constructor}.
Other possibilities for \textsf{Result} are \textsf{eof}, indicating the end-of-file has
been reached, and \textsf{error(ErrorCode)}, indicating that something went wrong.

Then an \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} decides what to do.  The \textsf{\textbf{if}} condition succeeds
if \textsf{Result} is an \textsf{ok} value (unifying \textsf{String} with the argument) and
if \\ \textsf{string.to\_int(string.strip(String), N)} succeeds.  The \textsf{string.strip}
function returns its argument minus any leading and trailing whitespace,
including the terminating newline character, while the predicate
\textsf{string.to\_int} succeeds if its first argument is a string of decimal digits
(unifying \textsf{N} with the corresponding number), and fails otherwise.

It's worth taking a slightly closer look at the unification in the \textsf{\textbf{if}} part
of the \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} goal:
\begin{small}

\begin{ptabular}
\column{col10}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{col10}{\hspace*{2.7em}}
\fromto{col10}{colend}{\textsf{Result {\ensuremath{=}} ok(String)}}
\nextline
\end{ptabular}

\end{small}
We know that \textsf{Result} has a value at this point, so this kind of unification
is known as a \emph{deconstruction}: it only succeeds if the value in
\textsf{Result} matches the pattern \textsf{ok(}\emph{something}\textsf{)}, in which case it
unifies \textsf{String} with the \emph{something}.

The \textsf{\textbf{then}} and \textsf{\textbf{else}} arms of the \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} goal call the \textsf{io.format}
predicate, which is rather like C's \textsf{printf} function.  The first argument
is a format string (where \textsf{\%d} indicates a decimal integer, \textsf{\%f} indicates a
floating point value, \textsf{\%s} indicates a string, and \textsf{\%c} indicates a
character)
and the second argument is a list of the corresponding values in \textsf{\char`\[{}}
brackets \textsf{\char`\]{}}, tagged with \textsf{i}, \textsf{f}, \textsf{s} or \textsf{c} for \textsf{int}, \textsf{float}, \textsf{string}
or \textsf{char} values respectively.  Thus in
\begin{small}

\begin{ptabular}
\column{col10}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{col10}{\hspace*{2.7em}}
\fromto{col10}{colend}{\textsf{io.format(``fib(\%d) {\ensuremath{=}} \%d{\ensuremath{\backslash}}n'', \char`\[{}i(N), i(fib(N))\char`\]{}, !IO)}}
\nextline
\end{ptabular}

\end{small}
the \textsf{int} \textsf{N} is printed instead of the first \textsf{\%d} in the format string
and the \textsf{int} result of \textsf{fib(N)} is printed instead of the second \textsf{\%d}.
If \textsf{N {\ensuremath{=}} 17} we'd expect this goal to output
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{fib(17) {\ensuremath{=}} 1597}}
\nextline
\end{ptabular}

\end{small}
Just as the Mercury compiler doesn't know how to do anything with integers
unless you import the \textsf{int} module, it doesn't know anything about lists
unless you import the \textsf{list} module.  So if you want to use \textsf{io.format} then
you also have to import the \textsf{list} and \textsf{string} modules.

Okay, so far so good.  What if we want to input more than one number in a
loop?
That's easy to arrange:
\begin{small}

\begin{ptabular}
\column{col10}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col8}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.read\_line\_as\_string(Result, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{col8}{\textsf{(}}
\fromto{col8}{colend}{\textsf{\textbf{if}}}
\nextline
\fromto{col1}{col10}{\hspace*{2.7em}}
\fromto{col10}{colend}{\textsf{Result {\ensuremath{=}} ok(String),}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{string.to\_int(string.strip(String), N)}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{then}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{io.format(``fib(\%d) {\ensuremath{=}} \%d{\ensuremath{\backslash}}n'', \char`\[{}i(N), i(fib(N))\char`\]{}, !IO),}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{main(!IO)}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{else}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{io.format(``I didn't expect that...{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
Now the \textsf{\textbf{then}} branch calls \textsf{main} recursively to read in another number.
Being a declarative language, recursion is Mercury's only looping
construct.  However, as with any decent declarative language compiler worth
it's salt, tail recursion like this is just as efficient as a \textsf{while} or
\textsf{for} loop in any other language.

Firing up the compiler we get
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{\char`\${} mmc {\ensuremath{-}}{\ensuremath{-}}make fib}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/int3s/fib.int3}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/cs/fib.c}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/os/fib.o}}
\nextline
\fromto{col1}{colend}{\textsf{Making fib}}
\nextline
\fromto{col1}{colend}{\textsf{\char`\${} ./fib}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ 10}}
\nextline
\fromto{col1}{colend}{\textsf{fib(10) {\ensuremath{=}} 55}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ 17}}
\nextline
\fromto{col1}{colend}{\textsf{fib(17) {\ensuremath{=}} 1597}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ 20}}
\nextline
\fromto{col1}{colend}{\textsf{fib(20) {\ensuremath{=}} 6765}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ \char`\^{}D}}
\nextline
\fromto{col1}{colend}{\textsf{I didn't expect that...}}
\nextline
\end{ptabular}

\end{small}
(The \textsf{$|$}s indicate input from the user and don't actually appear on the
screen.  \textsf{\char`\^{}D} indicates the user typing \textsf{Ctrl{\ensuremath{-}}D} to close the input stream;
Windows users should use \textsf{Ctrl{\ensuremath{-}}Z}.)

It would be good to handle the end-of-file condition more gracefully.  The
obvious way to do that is to add another case to the \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}}:
\begin{small}

\begin{ptabular}
\column{col10}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col8}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.read\_line\_as\_string(Result, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{col8}{\textsf{(}}
\fromto{col8}{colend}{\textsf{\textbf{if}}}
\nextline
\fromto{col1}{col10}{\hspace*{2.7em}}
\fromto{col10}{colend}{\textsf{Result {\ensuremath{=}} eof}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{then}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{io.format(``bye bye...{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{else} \textbf{if}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{Result {\ensuremath{=}} ok(String),}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{string.to\_int(string.strip(String), N)}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{then}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{io.format(``fib(\%d) {\ensuremath{=}} \%d{\ensuremath{\backslash}}n'', \char`\[{}i(N), i(fib(N))\char`\]{}, !IO),}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{main(!IO)}}
\nextline
\fromto{col1}{col8}{\textsf{}}
\fromto{col8}{colend}{\textsf{\textbf{else}}}
\nextline
\fromto{col1}{col10}{\textsf{}}
\fromto{col10}{colend}{\textsf{io.format(``I didn't expect that...{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
Observe the deconstruction test of \textsf{Result} with \textsf{eof} --- the \textsf{eof} data
constructor has no argument list and indeed it is a syntax error to write
\textsf{eof()}.

Before we leave our \textsf{fib} example, let us introduce Mercury's \emph{switch}
goals.  A switch goal is rather like C's \textsf{switch} statement and consists of
a set of alternatives testing a given variable against different possible
values it might have.  Here is \textsf{main} rewritten to use a switch goal:
\begin{small}

\begin{ptabular}
\column{col12}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col18}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.read\_line\_as\_string(Result, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{(}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} eof,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.format(``bye bye...{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{;}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} ok(String),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col12}{\textsf{(}}
\fromto{col12}{col18}{\textsf{\textbf{if}}}
\fromto{col18}{colend}{\textsf{string.to\_int(string.strip(String), N)}}
\nextline
\fromto{col1}{col12}{\textsf{}}
\fromto{col12}{col18}{\textsf{\textbf{then}}}
\fromto{col18}{colend}{\textsf{io.format(``fib(\%d) {\ensuremath{=}} \%d{\ensuremath{\backslash}}n'', \char`\[{}i(N), i(fib(N))\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col12}{\textsf{}}
\fromto{col12}{col18}{\textsf{\textbf{else}}}
\fromto{col18}{colend}{\textsf{io.format(``that isn't a number{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{main(!IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{;}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} error(ErrorCode),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.format(``\%s{\ensuremath{\backslash}}n'', \char`\[{}s(io.error\_message(ErrorCode))\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
A sequence of goals separated by semicolons is called a \emph{disjunction}
(the semicolon is usually pronounced ``or'').  If each \emph{disjunct}
deconstructs a particular variable against a set of mutually exclusive
possibilities, then the disjunction as a whole is a switch.
In general it is good style to
use a switch rather than a sequence of \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} goals since then, in
most cases, the Mercury compiler will tell you if you've forgotten a
possibility or counted the same possibility twice.

\subsection*{Points to remember}

\begin{itemize}
\item Some types (such as the result type of \textsf{io.read\_line\_as\_string}) use
different data constructors for different values.  These values can be
tested using deconstruction unifications.
\item A data constructor with no arguments, such as \textsf{eof}, is not followed
by an argument list.
\item \textsf{io.format} is Mercury's version of C's \textsf{printf}.  To use it you must
import \textsf{list} and \textsf{string} as well as the \textsf{io} module.
\item You should omit the parentheses around an \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} that
immediately follows the \textsf{\textbf{else}} part of another \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}}.
\item A disjunction is a sequence of goals separated by semicolons.
\item A switch is a disjunction where each disjunct tests a particular
variable against a different possibility.  Where applicable, switches are
generally preferable to \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}}s.
\end{itemize}





\newpage





\section{\textsf{rot13}}

Let's move on to a different example.  This time we are going to implement
the \textsf{rot13} ``encryption'' algorithm, which works by rotating the Roman
alphabet by 13 places --- in other words, \textsf{abcdefghijklmnopqrstuvwxyz} in
the input becomes \textsf{nopqrstuvwxyzabcdefghijklm} in the output.  Decryption is
simple: just use \textsf{rot13} a second time!  While \textsf{rot13} has the cryptographic
strength of damp tissue paper, it is sometimes useful for obscuring
information in an e-mail that the recipient may not yet wish to know,
such as who won the Grand Final.

Here's a first cut at a solution:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col40}{@{\ }l@{}}
\column{col16}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col28}{@{\ }l@{}}
\column{col19}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{module} rot13.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{interface}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} io.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} main(io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{implementation}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} char, list, string.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.read\_char(Result, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{(}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} ok(Char),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.write\_char(rot13(Char), !IO),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{main(!IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{;}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} eof}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{;}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} error(ErrorCode),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.format(``\%s{\ensuremath{\backslash}}n'', \char`\[{}s(io.error\_message(ErrorCode))\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{func} rot13(char) {\ensuremath{=}} char.}}
\nextline
\nextline
\fromto{col1}{col16}{\textsf{rot13(Char) {\ensuremath{=}}}}
\fromto{col16}{col19}{\textsf{(}}
\fromto{col19}{col28}{\textsf{\textbf{if}}}
\fromto{col28}{col40}{\textsf{Char {\ensuremath{=}} 'a'}}
\fromto{col40}{colend}{\textsf{\textbf{then} 'n'}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{col28}{\textsf{\textbf{else} \textbf{if}}}
\fromto{col28}{col40}{\textsf{Char {\ensuremath{=}} 'b'}}
\fromto{col40}{colend}{\textsf{\textbf{then} 'o'}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{colend}{\textsf{...}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{col28}{\textsf{\textbf{else} \textbf{if}}}
\fromto{col28}{col40}{\textsf{Char {\ensuremath{=}} 'z'}}
\fromto{col40}{colend}{\textsf{\textbf{then} 'm'}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{col28}{\textsf{\textbf{else} \textbf{if}}}
\fromto{col28}{col40}{\textsf{Char {\ensuremath{=}} 'A'}}
\fromto{col40}{colend}{\textsf{\textbf{then} 'N'}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{col28}{\textsf{\textbf{else} \textbf{if}}}
\fromto{col28}{col40}{\textsf{Char {\ensuremath{=}} 'B'}}
\fromto{col40}{colend}{\textsf{\textbf{then} 'O'}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{colend}{\textsf{...}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{col28}{\textsf{\textbf{else} \textbf{if}}}
\fromto{col28}{col40}{\textsf{Char {\ensuremath{=}} 'Z'}}
\fromto{col40}{colend}{\textsf{\textbf{then} 'M'}}
\nextline
\fromto{col1}{col19}{\textsf{}}
\fromto{col19}{col28}{\textsf{\textbf{else}}}
\fromto{col28}{colend}{\textsf{Char}}
\nextline
\fromto{col1}{col16}{\textsf{}}
\fromto{col16}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
While this plainly works:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{\char`\${} mmc {\ensuremath{-}}{\ensuremath{-}}make rot13}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/int3s/rot13.int3}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/cs/rot13.c}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/os/rot13.o}}
\nextline
\fromto{col1}{colend}{\textsf{Making rot13}}
\nextline
\fromto{col1}{colend}{\textsf{\char`\${} ./rot13}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ Port Adelaide beat the Brisbane Lions 113 to 73 in the Grand Final.}}
\nextline
\fromto{col1}{colend}{\textsf{Cbeg Nqrynvqr orng gur Oevfonar Yvbaf 113 gb 73 va gur Tenaq Svany.}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ Cbeg Nqrynvqr orng gur Oevfonar Yvbaf 113 gb 73 va gur Tenaq Svany.}}
\nextline
\fromto{col1}{colend}{\textsf{Port Adelaide beat the Brisbane Lions 113 to 73 in the Grand Final.}}
\nextline
\end{ptabular}

\end{small}
it's hardly going to win prizes for elegance or efficiency.  A more
experienced Mercury programmer might code \textsf{rot13} like this:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col15}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{func} rot13(char) {\ensuremath{=}} char.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{rot13(CharIn) {\ensuremath{=}} ( \textbf{if} rot13\_2(CharIn, CharOut) \textbf{then} CharOut \textbf{else} CharIn ).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} rot13\_2(char::in, char::out) \textbf{is} \textbf{semidet}.}}
\nextline
\nextline
\fromto{col1}{col15}{\textsf{rot13\_2('a',}}
\fromto{col15}{colend}{\textsf{'n').}}
\nextline
\fromto{col1}{col15}{\textsf{rot13\_2('b',}}
\fromto{col15}{colend}{\textsf{'o').}}
\nextline
\fromto{col1}{colend}{\textsf{...}}
\nextline
\fromto{col1}{col15}{\textsf{rot13\_2('z',}}
\fromto{col15}{colend}{\textsf{'m').}}
\nextline
\fromto{col1}{col15}{\textsf{rot13\_2('A',}}
\fromto{col15}{colend}{\textsf{'N').}}
\nextline
\fromto{col1}{col15}{\textsf{rot13\_2('B',}}
\fromto{col15}{colend}{\textsf{'O').}}
\nextline
\fromto{col1}{colend}{\textsf{...}}
\nextline
\fromto{col1}{col15}{\textsf{rot13\_2('Z',}}
\fromto{col15}{colend}{\textsf{'M').}}
\nextline
\end{ptabular}

\end{small}
There are three new things here: the \textsf{\textbf{semidet}} determinism category;
clauses with the arguments already ``filled in''; and using more than one
clause to define a predicate.

First off, the \textsf{\textbf{semidet}} determinism category means that \textsf{rot13\_2} will, for
any given input, either fail or have a single solution for the output.
Looking at the
code we might guess (correctly) that \textsf{rot13\_2('z', X)} should succeed
unifying \textsf{X {\ensuremath{=}} 'm'} (and never anything else), while \textsf{rot13\_2('7', X)}
would fail.

Secondly, a clause like
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{rot13\_2('a', 'n').}}
\nextline
\end{ptabular}

\end{small}
is just syntactic sugar for
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{rot13\_2(V$_{1}$, V$_{2}$) :{\ensuremath{-}} V$_{1}$ {\ensuremath{=}} 'a', V$_{2}$ {\ensuremath{=}} 'n'.}}
\nextline
\end{ptabular}

\end{small}
Since we know from the \textsf{\textbf{pred}} declaration for \textsf{rot13\_2} that \textsf{V$_{1}$} is an
input and \textsf{V$_{2}$} an output, the unification \textsf{V$_{1}$ {\ensuremath{=}} 'a'} must be a
deconstruction test and, if that succeeds, then the \emph{construction}
unification \textsf{V$_{2}$ {\ensuremath{=}} 'n'} is carried out (a construction unification always
succeeds because the ``destination'' variable, \textsf{V$_{2}$} in this case, does not
have a value before this point).

Finally, a sequence of clauses is syntactic sugar for a single clause whose
body is a disjunction.  Hence our code is transformed by the compiler
into this:
\begin{small}

\begin{ptabular}
\column{col20}{@{\ }l@{}}
\column{col21}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col23}{@{\ }l@{}}
\column{col24}{@{\ }l@{}}
\column{col34}{@{\ }l@{}}
\column{col35}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{col21}{\textsf{rot13\_2(V$_{1}$, V$_{2}$) :{\ensuremath{-}}}}
\fromto{col21}{col24}{\textsf{(}}
\fromto{col24}{col35}{\textsf{V$_{1}$ {\ensuremath{=}} 'a',}}
\fromto{col35}{colend}{\textsf{V$_{2}$ {\ensuremath{=}} 'n'}}
\nextline
\fromto{col1}{col20}{\hspace*{5.7em}}
\fromto{col20}{col23}{\textsf{;}}
\fromto{col23}{col34}{\textsf{V$_{1}$ {\ensuremath{=}} 'b',}}
\fromto{col34}{colend}{\textsf{V$_{2}$ {\ensuremath{=}} 'o'}}
\nextline
\fromto{col1}{col23}{\textsf{}}
\fromto{col23}{colend}{\textsf{...}}
\nextline
\fromto{col1}{col20}{\textsf{}}
\fromto{col20}{col23}{\textsf{;}}
\fromto{col23}{col34}{\textsf{V$_{1}$ {\ensuremath{=}} 'z',}}
\fromto{col34}{colend}{\textsf{V$_{2}$ {\ensuremath{=}} 'm'}}
\nextline
\fromto{col1}{col20}{\textsf{}}
\fromto{col20}{col23}{\textsf{;}}
\fromto{col23}{col34}{\textsf{V$_{1}$ {\ensuremath{=}} 'A',}}
\fromto{col34}{colend}{\textsf{V$_{2}$ {\ensuremath{=}} 'N'}}
\nextline
\fromto{col1}{col20}{\textsf{}}
\fromto{col20}{col23}{\textsf{;}}
\fromto{col23}{col34}{\textsf{V$_{1}$ {\ensuremath{=}} 'B',}}
\fromto{col34}{colend}{\textsf{V$_{2}$ {\ensuremath{=}} 'O'}}
\nextline
\fromto{col1}{col23}{\textsf{}}
\fromto{col23}{colend}{\textsf{...}}
\nextline
\fromto{col1}{col20}{\textsf{}}
\fromto{col20}{col23}{\textsf{;}}
\fromto{col23}{col34}{\textsf{V$_{1}$ {\ensuremath{=}} 'Z',}}
\fromto{col34}{colend}{\textsf{V$_{2}$ {\ensuremath{=}} 'M' ).}}
\nextline
\end{ptabular}

\end{small}
The astute reader will immediately identify this as a switch on \textsf{V$_{1}$} because
each disjunct tests the input \textsf{V$_{1}$} for a different possible value.  One of
the good things about switches is that the Mercury compiler will generate
very efficient code for them, using a lookup-table or hash-table perhaps,
which will certainly out-perform the long \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} chain in our
first attempt.

(As an aside, the \textsf{\textbf{is} \textbf{semidet}} determinism declaration for \textsf{rot13\_2} tells
the Mercury compiler that this predicate is expected to fail in some cases,
so it will not warn us about missing possible values for the first argument.
In the \textsf{fib} program the switch had to be exhaustive, so it could not fail,
because \textsf{main} was declared to be \textsf{\textbf{det}}.  Had we missed a possible case out
of that switch, the compiler would have reported the missing case as an
error.  Similarly, because \textsf{rot13\_2} cannot have more than one solution for
any input, the compiler will report an error if we have duplicate clauses
matching the same input.  The compiler can't warn us about such problems if
we use \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} chains.  Try it and see what happens.)

Note that if we felt so inclined, we could make \textsf{rot13\_2} deterministic by
including the translation of every possible character!  Of course, there are
many ways of coding \textsf{rot13} and while our implementation may not be the most
concise, it is quite efficient and very easy to understand.  Either way, our
aim here was to look more closely at the concept of semideterminism and
introduce the technique of making code more readable by using multiple
clauses to define a predicate or function.

\subsection*{Points to remember}

\begin{itemize}
\item Literal character values in Mercury are normally enclosed in single
quotes.  Some characters which the Mercury parser would normally expect to
see used as infix function symbols, such as \textsf{{\ensuremath{+}}} and \textsf{{\ensuremath{*}}}, also need to be
enclosed in parentheses: \textsf{('{\ensuremath{+}}')} and \textsf{('{\ensuremath{*}}')}.  Full details of how special
characters should be written can be found in the the Mercury Reference
Manual.
\item The \textsf{\textbf{semidet}} determinism category means that a predicate can have
at most one \emph{solution} for a given set of inputs (it fails if it has no
solution for the given inputs).
\item Semideterministic predicates therefore often appear in the conditions
of \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} goals.
\item ``Filling in'' the arguments of a clause is just shorthand for
omitting the equivalent unification goals.
\item The compiler views a predicate or function definition comprising
several clauses as a single disjunction.
Multiple clauses are often easier to read than a large disjunction.
\end{itemize}





\newpage




\section{Cryptarithms}

In this example we introduce nondeterminism to demonstrate a
little of what differentiates Mercury from conventional programming
languages.  A cryptarithm is an
equation (usually just an addition) where the digits of each number have
been replaced by letters, \textsf{DOG {\ensuremath{+}} ANT {\ensuremath{=}} CAT} for example; a solution is a
mapping from letters to digits that satisfies the equation.  Leading letters
cannot stand for zero and each letter must stand for a distinct digit.
Here's a Mercury program to solve this particular cryptarithm:
\begin{small}

\begin{ptabular}
\column{col10}{@{\ }l@{}}
\column{col77}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col14}{@{\ }l@{}}
\column{col43}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col26}{@{\ }l@{}}
\column{col17}{@{\ }l@{}}
\column{col36}{@{\ }l@{}}
\column{col7}{@{\ }l@{}}
\column{col64}{@{\ }l@{}}
\column{col29}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\column{col48}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{module} crypt.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{interface}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} io.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} main(io::di, io::uo) \textbf{is} \textbf{cc\_multi}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{implementation}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} int, list, string.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.format(``DOG {\ensuremath{+}} ANT {\ensuremath{=}} CAT{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{( \textbf{if}}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{col48}{\textsf{Ds$_{0}$ {\ensuremath{=}} \char`\[{}0, 1, 2, 3, 4, 5, 6, 7, 8, 9\char`\]{},}}
\fromto{col48}{colend}{\textsf{C$_{0}$ {\ensuremath{=}} 0,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{pick(Ds$_{0}$, G, Ds$_{1}$),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col29}{\textsf{pick(Ds$_{1}$, T, Ds$_{2}$),}}
\fromto{col29}{col43}{\textsf{S$_{1}$ {\ensuremath{=}} G{\ensuremath{+}}T{\ensuremath{+}}C$_{0}$,}}
\fromto{col43}{col64}{\textsf{T {\ensuremath{=}} S$_{1}$ mod 10,}}
\fromto{col64}{colend}{\textsf{C$_{1}$ {\ensuremath{=}} S$_{1}$/10,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{pick(Ds$_{2}$, O, Ds$_{3}$),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col29}{\textsf{pick(Ds$_{3}$, N, Ds$_{4}$),}}
\fromto{col29}{col43}{\textsf{S$_{2}$ {\ensuremath{=}} O{\ensuremath{+}}N{\ensuremath{+}}C$_{1}$,}}
\fromto{col43}{col64}{\textsf{A {\ensuremath{=}} S$_{2}$ mod 10,}}
\fromto{col64}{col77}{\textsf{C$_{2}$ {\ensuremath{=}} S$_{2}$/10,}}
\fromto{col77}{colend}{\textsf{A {\ensuremath{\backslash}}{\ensuremath{=}} 0,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{pick(Ds$_{4}$, D, Ds$_{5}$),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col29}{\textsf{pick(Ds$_{5}$, A, Ds$_{6}$),}}
\fromto{col29}{col43}{\textsf{S$_{3}$ {\ensuremath{=}} D{\ensuremath{+}}A{\ensuremath{+}}C$_{2}$,}}
\fromto{col43}{col64}{\textsf{C {\ensuremath{=}} S$_{3}$ mod 10,}}
\fromto{col64}{col77}{\textsf{C$_{3}$ {\ensuremath{=}} S$_{3}$/10,}}
\fromto{col77}{colend}{\textsf{C {\ensuremath{\backslash}}{\ensuremath{=}} 0,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{pick(Ds$_{6}$, C, \_),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{C$_{3}$ {\ensuremath{=}} 0}}
\nextline
\fromto{col1}{col7}{\hspace*{1.8em}}
\fromto{col7}{colend}{\textsf{\textbf{then}}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col14}{\textsf{DOG}}
\fromto{col14}{col17}{\textsf{{\ensuremath{=}}}}
\fromto{col17}{col26}{\textsf{100 {\ensuremath{*}} D}}
\fromto{col26}{col36}{\textsf{{\ensuremath{+}} 10 {\ensuremath{*}} O}}
\fromto{col36}{colend}{\textsf{{\ensuremath{+}} G,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col14}{\textsf{ANT}}
\fromto{col14}{col17}{\textsf{{\ensuremath{=}}}}
\fromto{col17}{col26}{\textsf{100 {\ensuremath{*}} A}}
\fromto{col26}{col36}{\textsf{{\ensuremath{+}} 10 {\ensuremath{*}} N}}
\fromto{col36}{colend}{\textsf{{\ensuremath{+}} T,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col14}{\textsf{CAT}}
\fromto{col14}{col17}{\textsf{{\ensuremath{=}}}}
\fromto{col17}{col26}{\textsf{100 {\ensuremath{*}} C}}
\fromto{col26}{col36}{\textsf{{\ensuremath{+}} 10 {\ensuremath{*}} A}}
\fromto{col36}{colend}{\textsf{{\ensuremath{+}} T,}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.format(``\%d {\ensuremath{+}} \%d {\ensuremath{=}} \%d{\ensuremath{\backslash}}n'', \char`\[{}i(DOG), i(ANT), i(CAT)\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col7}{\textsf{}}
\fromto{col7}{colend}{\textsf{\textbf{else}}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.format(``has no solutions{\ensuremath{\backslash}}n'', \char`\[{}\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\nextline
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{pred}}}
\fromto{col10}{colend}{\textsf{pick(list(int)::in, int::out, list(int)::out) \textbf{is} \textbf{nondet}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{pick(\char`\[{}X $|$ Xs\char`\]{}, X, Xs).}}
\nextline
\fromto{col1}{colend}{\textsf{pick(\char`\[{}X $|$ Xs\char`\]{}, Y, \char`\[{}X $|$ Zs\char`\]{}) :{\ensuremath{-}} pick(Xs, Y, Zs).}}
\nextline
\end{ptabular}

\end{small}
At this early stage we won't explain exactly \emph{how}
this program works.  Instead, we will describe \emph{what} it does and 
leave the technical explanation to later chapters.

The interesting part of this program is the condition of the \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}}
goal.  The trick to understanding this code fragment is to consider it as a
set of constraints on a solution rather than as a series of computations.
(Concentrating on the ``what'' rather than the ``how'' is a hallmark of
declarative programming.)

\textsf{Ds$_{0}$} is the list of digits from 0 to 9, \textsf{Ds$_{1}$} is \textsf{Ds$_{0}$} with the digit for
\textsf{G} removed, \textsf{Ds$_{2}$} is \textsf{Ds$_{1}$} with the digit for \textsf{T} removed, \textsf{Ds$_{3}$} is \textsf{Ds$_{2}$}
with the digit for \textsf{O} removed, and so forth.  In this way we ensure that
each of \textsf{D}, \textsf{O}, \textsf{G}, \textsf{A}, \textsf{N}, \textsf{T} and \textsf{C} are different.

The digits for each letter are selected nondeterministically using the
\textsf{pick} predicate.  The goal \textsf{pick(Ds$_{0}$, G, Ds$_{1}$)}, for instance, picks a digit
for \textsf{G} from \textsf{Ds$_{0}$} and leaves the remaining digits in \textsf{Ds$_{1}$}.  Since \textsf{Ds$_{0}$}
contains ten members, there are ten possible solutions for \textsf{G}, and \textsf{Ds$_{1}$}
will have nine members.

\textsf{C$_{1}$} is the carry from the units column, \textsf{C$_{2}$} is the carry 
from the tens column, \textsf{C$_{3}$} is the carry from the hundreds column; we
introduce \textsf{C$_{0}$} as a ``carry in'' of zero to give the program a regular
structure.

The goal
\textsf{S$_{1}$ {\ensuremath{=}} G {\ensuremath{+}} T {\ensuremath{+}} C$_{0}$, T {\ensuremath{=}} S$_{1}$ mod 10} provides the constraint for the units
column.  We do the same thing for the tens and hundreds columns.

The goals \textsf{A {\ensuremath{\backslash}}{\ensuremath{=}} 0} and \textsf{D {\ensuremath{\backslash}}{\ensuremath{=}} 0} ensure that we don't have any zeroes in the
hundreds column (`\textsf{{\ensuremath{\backslash}}{\ensuremath{=}}}' means ``not equal to''), while \textsf{C$_{3}$ {\ensuremath{=}} 0} ensures that
there is no carry left over from the hundreds column.

Eventually either a set of solutions to the \textsf{pick} goals will be found that
is consistent with the other constraints or, if no such set exists, 
the condition of the \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} will fail.

At this point we can explain the \textsf{\textbf{cc\_multi}} determinism category for \textsf{main},
which is different to \textsf{\textbf{det}} which we've used in all the preceding examples.
\textsf{\textbf{cc\_multi}} stands for \emph{committed choice multideterministic}, which means
that although this predicate may have multiple possible answers (there may
be multiple solutions to \textsf{main}'s \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} condition) we will only be
getting one of them!  This extra constraint is necessary to allow a
predicate with more than one possible solution to perform I/O; since we're
not allowed to backtrack over predicates that do I/O, we have to state that
we're content for \textsf{main} to stick to the first solution it finds, whichever
one that happens to be.

Now to outline how \textsf{pick} works; here is its definition again:
\begin{small}

\begin{ptabular}
\column{col10}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col50}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{col10}{\textsf{:{\ensuremath{-}} \textbf{pred}}}
\fromto{col10}{colend}{\textsf{pick(list(int)::in, int::out, list(int)::out) \textbf{is} \textbf{nondet}.}}
\nextline
\nextline
\fromto{col1}{col50}{\textsf{pick(\char`\[{}X $|$ Xs\char`\]{}, X, Xs).}}
\fromto{col50}{colend}{\textsf{\% Clause 1.}}
\nextline
\fromto{col1}{col50}{\textsf{pick(\char`\[{}X $|$ Xs\char`\]{}, Y, \char`\[{}X $|$ Zs\char`\]{}) :{\ensuremath{-}} pick(Xs, Y, Zs).}}
\fromto{col50}{colend}{\textsf{\% Clause 2.}}
\nextline
\end{ptabular}

\end{small}
The first argument is an input, the second and third are outputs.  The
\textsf{\textbf{nondet}} determinism category means that \textsf{pick} can have any number of
solutions, including zero, depending upon its input.
Clause 1 says that we can pick an item from a list whose first (head) item
is \textsf{X} and whose tail is \textsf{Xs} by returning \textsf{X} as the chosen item and \textsf{Xs}
as the remainder.
Clause 2 says that we can also pick an item from our list by choosing some
\textsf{Y} from \textsf{Xs}, leaving \textsf{Zs}, and returning \textsf{Y} as the chosen item and the
list \textsf{\char`\[{}X $|$ Zs\char`\]{}} as the remainder.

For example, The goal \textsf{pick(\char`\[{}1, 2, 3\char`\]{}, X, Xs)} has three possible solutions:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col32}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{col32}{\textsf{pick(\char`\[{}1, 2, 3\char`\]{}, 1, \char`\[{}2, 3\char`\]{})}}
\fromto{col32}{colend}{\textsf{\% By clause 1.}}
\nextline
\nextline
\fromto{col1}{col32}{\textsf{pick(\char`\[{}1, 2, 3\char`\]{}, 2, \char`\[{}1, 3\char`\]{})}}
\fromto{col32}{colend}{\textsf{\% By clause 2 because}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{col32}{\textsf{pick(\char`\[{}2, 3\char`\]{}, 2, \char`\[{}3\char`\]{})}}
\fromto{col32}{colend}{\textsf{\% by clause 1.}}
\nextline
\nextline
\fromto{col1}{col32}{\textsf{pick(\char`\[{}1, 2, 3\char`\]{}, 3, \char`\[{}1, 2\char`\]{})}}
\fromto{col32}{colend}{\textsf{\% By clause 2 because}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{col32}{\textsf{pick(\char`\[{}2, 3\char`\]{}, 3, \char`\[{}2\char`\]{})}}
\fromto{col32}{colend}{\textsf{\% by clause 2 because}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{col32}{\textsf{pick(\char`\[{}3\char`\]{}, 3, \char`\[{}\char`\]{})}}
\fromto{col32}{colend}{\textsf{\% by clause 1.}}
\nextline
\end{ptabular}

\end{small}
Each of these solutions will be enumerated by Mercury on backtracking.
(Note that the goal \textsf{pick(\char`\[{}\char`\]{}, X, Xs)} has no solution because there are no
clauses matching the empty list \textsf{\char`\[{}\char`\]{}} as an input.)

Don't worry if much of this seems confusing: once some facility with
thinking declaratively (\ie ``what'' rather than ``how'') is acquired, one
can look at predicates like \textsf{pick} and complicated goals like
the condition of this \textsf{\textbf{if}{\ensuremath{-}}\textbf{then}{\ensuremath{-}}\textbf{else}} and immediately understand what is
meant.  The thing to carry away from this example is the ease with which
Mercury allows us to describe a solution to a complex search problem.  We
have done very little more than write a logical specification of the problem
using Mercury syntax, all the tedious operational details are handled for us
by the compiler!  Elegance of this sort is one of the key things that makes
Mercury such an attractive programming language.

Anyway, after all that hard work, let's just prove that all this magic
actually works:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col13}{@{\ }l@{}}
\column{col6}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{\char`\${} mmc {\ensuremath{-}}{\ensuremath{-}}make crypt}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/int3s/crypt.int3}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/cs/crypt.c}}
\nextline
\fromto{col1}{colend}{\textsf{Making Mercury/os/crypt.o}}
\nextline
\fromto{col1}{colend}{\textsf{Making crypt}}
\nextline
\fromto{col1}{colend}{\textsf{\char`\${} ./crypt}}
\nextline
\fromto{col1}{col6}{\textsf{DOG}}
\fromto{col6}{col13}{\textsf{{\ensuremath{+}} ANT}}
\fromto{col13}{colend}{\textsf{{\ensuremath{=}} CAT}}
\nextline
\fromto{col1}{col6}{\textsf{420}}
\fromto{col6}{col13}{\textsf{{\ensuremath{+}} 531}}
\fromto{col13}{colend}{\textsf{{\ensuremath{=}} 951}}
\nextline
\end{ptabular}

\end{small}
Success!

\subsection*{Points to remember}

\begin{itemize}
\item Nondeterministic predicates such as \textsf{pick} can have multiple solutions
for a given set of inputs.  Mercury handles this by backtracking to the most
recent choice point when a later goal fails.
\item As far as possible, try to think declaratively rather than
operationally: focus on what it is that is being computed rather than how
the computation should proceed.  Leave as much of that sort of detail to the
compiler as you can.
\item Unification goals are quite versatile: they can denote constructions,
deconstructions, and equality tests.
\end{itemize}
\setcounter{chapter}{1}
% vim: ft=tex ff=unix ts=4 sw=4 et tw=76

\chapter{Lists, IO, and Arithmetic}


This chapter covers the basics of three fundamental modules from the
standard library: \textsf{list} for the list data structure, \textsf{io} for input/output,
and \textsf{int} for integer arithmetic.

Lists are one of the most frequently used data structures.
The Mercury list data type has two data constructors: \textsf{\char`\[{}\char`\]{}} for the
empty list and \textsf{\char`\[{}X $|$ Xs\char`\]{}} for the non-empty list whose head (first item) is
\textsf{X} and whose tail (remainder) is the list \textsf{Xs}.
Mercury provides some syntactic sugar to make working with lists more
convenient: \textsf{\char`\[{}1, 2, 3\char`\]{}} is shorthand for \textsf{\char`\[{}1 $|$ \char`\[{}2 $|$ \char`\[{}3 $|$ \char`\[{}\char`\]{}\char`\]{}\char`\]{}\char`\]{}} and
\textsf{\char`\[{}1, 2 $|$ Xs\char`\]{}} is shorthand for \textsf{\char`\[{}1 $|$ \char`\[{}2 $|$ Xs\char`\]{}\char`\]{}}.



\section{Reading and summing a list of ints}

We begin with a simple example: reading in some numbers and computing
their sum.
Start by putting the the usual header boilerplate in a file
\textsf{listdemo.m}:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{module} listdemo.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{interface}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} io.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} main(io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{implementation}.}}
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{import\_module} list, int, string.}}
\nextline
\end{ptabular}

\end{small}
Now we want to define the \textsf{main} predicate to read in a line of input,
convert it to a list of integers, and do something with them (in this case,
print out their sum).
\begin{small}

\begin{ptabular}
\column{col11}{@{\ }l@{}}
\column{col1}{@{\ }l@{}}
\column{col13}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col62}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{main(!IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.write\_string(``Type in a few integers separated by spaces:{\ensuremath{\backslash}}n'', !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{io.read\_line\_as\_string(Result, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{(}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} eof}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{;}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} error(ErrorCode),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.format(``\%s{\ensuremath{\backslash}}n'', \char`\[{}s(io.error\_message(ErrorCode))\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{;}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{Result {\ensuremath{=}} ok(String),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{( \textbf{if} string\_to\_ints(String, Ints) \textbf{then}}}
\nextline
\fromto{col1}{col13}{\hspace*{3.6em}}
\fromto{col13}{colend}{\textsf{process\_ints(Ints, !IO)}}
\nextline
\fromto{col1}{col11}{\hspace*{3em}}
\fromto{col11}{colend}{\textsf{\textbf{else}}}
\nextline
\fromto{col1}{col13}{\textsf{}}
\fromto{col13}{col62}{\textsf{io.write\_string("I think you've made a mistake.}}
\fromto{col62}{colend}{\textsf{Try again.{\ensuremath{\backslash}}n", !IO),}}
\nextline
\fromto{col1}{col13}{\textsf{}}
\fromto{col13}{colend}{\textsf{main(!IO)}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{)}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
This all looks straightforward.
Next we have to define the \textsf{string\_to\_ints}
and \textsf{process\_ints} predicates.
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} string\_to\_ints(string::in, list(int)::out) \textbf{is} \textbf{semidet}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{string\_to\_ints(String, Ints) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{IntStrings {\ensuremath{=}} string.words(String),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{strings\_to\_ints(IntStrings, Ints).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} strings\_to\_ints(list(string)::in, list(int)::out) \textbf{is} \textbf{semidet}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{strings\_to\_ints(\char`\[{}\char`\]{}, \char`\[{}\char`\]{}).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{strings\_to\_ints(\char`\[{}IntString $|$ IntStrings\char`\]{}, \char`\[{}Int $|$ Ints\char`\]{}) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{string.to\_int(IntString, Int),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{strings\_to\_ints(IntStrings, Ints).}}
\nextline
\end{ptabular}

\end{small}
The \textsf{string\_to\_ints} is predicate is \textsf{\textbf{semidet}} because it calls
\textsf{strings\_to\_ints}, which can fail; \textsf{strings\_to\_ints} is \textsf{\textbf{semidet}} because it
calls \textsf{string.to\_int} which can fail.

Observe the argument types used here: \textsf{list(string)} and \textsf{list(int)},
meaning ``list of strings'' and ``list of ints'' respectively.
In Mercury,
each list can only hold members of a single type --- for
example, you can't mix ints and strings in the same list.

The \textsf{string.words} function splits one string into a list of strings, taking
whitespace (spaces, tabs, etc.) to be the ``word'' separator.
For example, \textsf{string.words(`` 1 2 3 '') {\ensuremath{=}} \char`\[{}``1'', ``2'', ``3''\char`\]{}}.

The first clause of \textsf{strings\_to\_ints} converts the empty list of strings
into the empty list of integers.
The second clause converts the non-empty
list of strings \textsf{\char`\[{}IntString $|$ IntStrings\char`\]{}} into the list of ints
\textsf{\char`\[{}Int $|$ Ints\char`\]{}} using \textsf{string.to\_int} to convert \textsf{IntString} to \textsf{Int} and
calling itself recursively to convert \textsf{IntStrings} to \textsf{Ints}.

Despite how it looks, the output \textsf{\char`\[{}Int $|$ Ints\char`\]{}} in the second clause
of \textsf{strings\_to\_ints} is actually constructed \emph{after} the body of the
clause has run, to ensure that \textsf{Int} and \textsf{Ints} have been given values.
That is, the Mercury compiler converts the definition given above into
something like this:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col45}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{strings\_to\_ints(Input, Output) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{\% Switch on Input.}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{(}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{col45}{\textsf{Input {\ensuremath{=}} \char`\[{}\char`\]{},}}
\fromto{col45}{colend}{\textsf{\% Deconstruction (i.e., pattern matching).}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col45}{\textsf{Output {\ensuremath{=}} \char`\[{}\char`\]{}}}
\fromto{col45}{colend}{\textsf{\% Construction.}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{;}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col45}{\textsf{Input {\ensuremath{=}} \char`\[{}IntString $|$ IntStrings\char`\]{},}}
\fromto{col45}{colend}{\textsf{\% Deconstruction.}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{string.to\_int(IntString, Int),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{strings\_to\_ints(IntStrings, Ints),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{col45}{\textsf{Output {\ensuremath{=}} \char`\[{}Int $|$ Ints\char`\]{}}}
\fromto{col45}{colend}{\textsf{\% Construction.}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}

Finally, we need to define the \textsf{process\_ints} predicate.
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} process\_ints(list(int)::in, io::di, io::uo) \textbf{is} \textbf{det}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{process\_ints(Ints, !IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.format(``Sum: \%d{\ensuremath{\backslash}}n'', \char`\[{}i(sum\_ints(Ints))\char`\]{}, !IO).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{func} sum\_ints(list(int)) {\ensuremath{=}} int.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{sum\_ints(\char`\[{}\char`\]{}) {\ensuremath{=}} 0.}}
\nextline
\fromto{col1}{colend}{\textsf{sum\_ints(\char`\[{}X $|$ Xs\char`\]{}) {\ensuremath{=}} X {\ensuremath{+}} sum\_ints(Xs).}}
\nextline
\end{ptabular}

\end{small}
The \textsf{sum\_ints} function defines the sum of the empty list to be zero (why?)
and the sum of the non-empty list \textsf{\char`\[{}X $|$ Xs\char`\]{}} to be \textsf{X} plus the sum of the
list \textsf{Xs}.

Let's see it in action:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col33}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{\char`\${} mmc {\ensuremath{-}}{\ensuremath{-}}make listdemo}}
\nextline
\fromto{col1}{colend}{\textsf{...}}
\nextline
\fromto{col1}{colend}{\textsf{\char`\${} ./listdemo}}
\nextline
\fromto{col1}{colend}{\textsf{Type in a few integers separated by spaces:}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ two four one three}}
\nextline
\fromto{col1}{col33}{\textsf{I think you've made a mistake.}}
\fromto{col33}{colend}{\textsf{Try again.}}
\nextline
\fromto{col1}{colend}{\textsf{Type in a few integers separated by spaces:}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ 2 4 1 3}}
\nextline
\fromto{col1}{colend}{\textsf{Sum: 10}}
\nextline
\end{ptabular}

\end{small}



\section{The minium and maximum of a list of ints}

Now we extend our program to find the minimum and maximum of the input:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col7}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{process\_ints(Ints, !IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.format(``Sum: \%d{\ensuremath{\backslash}}n'', \char`\[{}i(sum\_ints(Ints))\char`\]{}, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{( \textbf{if}}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{colend}{\textsf{min\_ints(Ints, Min),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{max\_ints(Ints, Max)}}
\nextline
\fromto{col1}{col7}{\hspace*{1.8em}}
\fromto{col7}{colend}{\textsf{\textbf{then}}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.format(``Min: \%d{\ensuremath{\backslash}}n'', \char`\[{}i(Min)\char`\]{}, !IO),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.format(``Max: \%d{\ensuremath{\backslash}}n'', \char`\[{}i(Max)\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col7}{\textsf{}}
\fromto{col7}{colend}{\textsf{\textbf{else}}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{\textbf{true}}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\end{ptabular}

\end{small}
Note: \textsf{\textbf{true}} is the Mercury built-in predicate that always succeeds and is used
where we need to ``do nothing''; there is a corresponding \textsf{\textbf{false}} predicate
that always fails.
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} min\_ints(list(int)::in, int::out) \textbf{is} \textbf{semidet}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{min\_ints(\char`\[{}X $|$ Xs\char`\]{}, Min) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{Min {\ensuremath{=}} min\_ints\_2(Xs, X).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{func} min\_ints\_2(list(int), int) {\ensuremath{=}} int.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{min\_ints\_2(\char`\[{}\char`\]{}, Min) {\ensuremath{=}} Min.}}
\nextline
\fromto{col1}{colend}{\textsf{min\_ints\_2(\char`\[{}X $|$ Xs\char`\]{}, Min) {\ensuremath{=}} min\_ints\_2(Xs, int.min(X, Min)).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{\char`\[{}...and similarly for max\_ints...\char`\]{}}}
\nextline
\end{ptabular}

\end{small}
\textsf{min\_ints} is \textsf{\textbf{semidet}} because it will fail if the input is the empty list
--- unlike \textsf{sum\_ints}, there is no sensible value for the minimum of the
empty list, hence we don't supply a clause matching this case.
If we really wanted to we could add the following:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{min\_ints(\char`\[{}\char`\]{}, \_) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{\textbf{false}.}}
\nextline
\end{ptabular}

\end{small}
where \textsf{\_} stands for ``don't care''.
In practice we simply omit clauses like this.

\textsf{min\_ints\_2} is \textsf{\textbf{det}} (it's a function): it uses an ``accumulator'',
\textsf{Min}, to track the smallest value seen so far and is defined for both empty
and non-empty lists.
The \textsf{int.min} function, from the \textsf{int} module in the
standard Mercury library, simply returns the smaller of its two arguments.

Here's our updated program in action:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{\char`\${} mmc {\ensuremath{-}}{\ensuremath{-}}make listdemo}}
\nextline
\fromto{col1}{colend}{\textsf{...}}
\nextline
\fromto{col1}{colend}{\textsf{\char`\${} ./listdemo}}
\nextline
\fromto{col1}{colend}{\textsf{Type in a few integers separated by spaces:}}
\nextline
\fromto{col1}{colend}{\textsf{$|$ 2 4 1 3}}
\nextline
\fromto{col1}{colend}{\textsf{Sum: 10}}
\nextline
\fromto{col1}{colend}{\textsf{Min: 1}}
\nextline
\fromto{col1}{colend}{\textsf{Max: 4}}
\nextline
\end{ptabular}

\end{small}

We can make our program slightly more efficient by computing the minimum and
maximum values in a single pass of the input list:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{col7}{@{\ }l@{}}
\column{col9}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{process\_ints(Ints, !IO) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{io.format(``Sum: \%d{\ensuremath{\backslash}}n'', \char`\[{}i(sum\_ints(Ints))\char`\]{}, !IO),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{( \textbf{if} min\_max\_ints(Ints, Min, Max) \textbf{then}}}
\nextline
\fromto{col1}{col9}{\hspace*{2.4em}}
\fromto{col9}{colend}{\textsf{io.format(``Min: \%d{\ensuremath{\backslash}}n'', \char`\[{}i(Min)\char`\]{}, !IO),}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{io.format(``Max: \%d{\ensuremath{\backslash}}n'', \char`\[{}i(Max)\char`\]{}, !IO)}}
\nextline
\fromto{col1}{col7}{\hspace*{1.8em}}
\fromto{col7}{colend}{\textsf{\textbf{else}}}
\nextline
\fromto{col1}{col9}{\textsf{}}
\fromto{col9}{colend}{\textsf{\textbf{true}}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} min\_max\_ints(list(int)::in, int::out, int::out) \textbf{is} \textbf{semidet}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{min\_max\_ints(\char`\[{}X $|$ Xs\char`\]{}, Min, Max) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{min\_max\_ints\_2(Xs, X, Min, X, Max).}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{pred} min\_max\_ints\_2(list(int)::in, int::in, int::out, int::in, int::out) \textbf{is} \textbf{semidet}.}}
\nextline
\nextline
\fromto{col1}{colend}{\textsf{min\_max\_ints\_2(\char`\[{}\char`\]{}, Min, Min, Max, Max).}}
\nextline
\fromto{col1}{colend}{\textsf{min\_max\_ints\_2(\char`\[{}X $|$ Xs\char`\]{}, Min$_{0}$, Min, Max$_{0}$, Max) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{Min$_{1}$ {\ensuremath{=}} int.min(X, Min$_{0}$),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{Max$_{1}$ {\ensuremath{=}} int.max(X, Max$_{0}$),}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{min\_max\_ints\_2(Xs, Min$_{1}$, Min, Max$_{1}$, Max).}}
\nextline
\end{ptabular}

\end{small}
We can't use a function for \textsf{min\_max\_ints\_2} because it has two outputs for
a given input, whereas functions only have one output.
Since there are two
outputs, it also has two accumulators, \textsf{Min$_{0}$} and \textsf{Max$_{0}$}, to track the
smallest and largest values seen so far.
The first clause, dealing with the
empty list input case, may look a little strange.
This is a standard
Mercury idiom exactly equivalent to writing
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{col5}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{min\_max\_ints\_2(\char`\[{}\char`\]{}, Min, MinOutput, Max, MaxOutput) :{\ensuremath{-}}}}
\nextline
\fromto{col1}{col5}{\hspace*{1.2em}}
\fromto{col5}{colend}{\textsf{MinOutput {\ensuremath{=}} Min,}}
\nextline
\fromto{col1}{col5}{\textsf{}}
\fromto{col5}{colend}{\textsf{MaxOutput {\ensuremath{=}} Max.}}
\nextline
\end{ptabular}

\end{small}
although this is more verbose and less readable.



\section{The List Data Type}

Apart from having special syntactic sugar, lists are not actually built into
Mercury: they are defined in the \textsf{list} standard Mercury library module the
same way any other type would be.
Here is the definition as it appears in
the \textsf{list} module:
\begin{small}

\begin{ptabular}
\column{col1}{@{\ }l@{}}
\column{colend}{@{\ }l@{}}
\fromto{col1}{colend}{\textsf{:{\ensuremath{-}} \textbf{type} list(T) {\ensuremath{-}}{\ensuremath{-}}{\ensuremath{-}}{\ensuremath{>}} \char`\[{}\char`\]{} ; \char`\[{}T $|$ list(T)\char`\]{}.}}
\nextline
\end{ptabular}

\end{small}

XXX HERE 

A list cell \textsf{\char`\[{}X $|$ Xs\char`\]{}} is represented in memory as a pair of pointers,
the first pointing to \textsf{X}, the second pointing to \textsf{Xs} (\ie Mercury
lists are singly linked lists).




% \setcounter{chapter}{2}
% %include 02-the-mercury-type-system.polytex
% \setcounter{chapter}{3}
% %include 03-the-mercury-mode-system.polytex

\end{document}
