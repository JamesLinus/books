% vim: ft=tex ff=unix ts=4 sw=4 et wm=8 tw=72

\chapter{Modules}

A Mercury program is made up of one or more \emph{modules} that are
compiled separately and then linked together to make a working
executable.  Modules serve three purposes: they allow code files to
be compiled and developed independently of the rest of the program; they
group sets of names into \emph{namespaces}; and they
control the \emph{visibility} of names.

\XXX{Should I add something along the lines that Mercury's module system
is simpler and, perhaps curiously, considerably more expressive than the
public/private/protected wobble used in Java/C$\sharp$/etc?}

\section{Module Structure}

Mercury modules look like this:
\begin{myverbatim}
:- module modulename.
:- interface.

    ...interface section...

:- implementation.

    ...implementation section...
\end{myverbatim}
A module called @modulename@ needs to go in a file called
@modulename.m@.  Consequently each file can contain only one module.
\XXX{I know this isn't strictly true when we talk about submodules, but
I really don't want to split hairs at this point.}

\subsection{Exported Names and Private Names}

Consider a file @a.m@ containing
\begin{myverbatim}
:- module a.
:- interface.

:- type foo ---> ...

:- func f(foo) = foo.

:- implementation.

:- type bar ---> ...

f(X) = ...

:- pred p(bar, foo).
:- mode p(in,  out) is det.

p(Y, Z) :- ...
\end{myverbatim}
Module @a@ \emph{exports} the names defined or declared in its interface
section.  In this case, @a@ exports the type @foo@ and the function
@f/1@.

Clauses defining predicates and functions are not allowed in the
interface section because we want to hide implementation detail from the
module's users.  The definition for @f/1@ therefore has to go in
@a@'s implementation section.

The names declared in @a@'s implementation section are \emph{private}.
In other words, they are not usable anywhere outside the implementation
section for @a@.  Here, the type @bar@ and the predicate @p/2@ are
private to @a@.

\subsection{Importing Modules}

Now consider the file @b.m@:
\begin{myverbatim}
:- module b.
:- interface.
:- import_module a.

:- type baz ---> ...

:- pred q(a.foo, baz).
:- mode q(in,    in ) is semidet.

:- implementation.

q(X, Y) :- ...
\end{myverbatim}
The @import_module@ declaration in the interface section of module @b@
allows @b@ to use names defined in module @a@ (in both the interface and
implementation sections).

Module @b@ exports the type @baz@ and the predicate @q/2@ whose first
argument is of type @a.foo@ (\ie the type @foo@ defined in module @a@)
and whose second argument is of type @baz@ (defined in module @b@).

Now let's look at file @c.m@:
\begin{myverbatim}
:- module c.
:- interface.
:- import_module b.

:- type quux ---> ...

:- func g(quux) = b.baz.

:- implementation.
:- import_module a.

g(X) = ...

:- pred r(a.foo, b.baz).
:- mode r(in,    out  ) is multi.

r(Y, Z) :- ...
\end{myverbatim}
Module @c@ imports module @b@ in its interface section and can therefore
use names exported by @b@ in both its interface and implementation
sections.  The function declaration for @g/1@ in the interface section
refers to @b.baz@, as does the predicate declaration for @r/2@ in the
implementation section.

The declaration for @r/2@ in the implementation section also refers to
@a.foo@.  Imports are not transitive, so module @c@ still has to
explicitly import module @a@ in order to use @a.foo@, regardless of the
fact that module @b@ imports module @a@ in its interface section.  Note
that the scope of the import declaration in the implementation section
extends only over that section and not to the interface section.

For economy of typing, it is possible to condense several import
declarations, such as
\begin{myverbatim}
:- import_module a.
:- import_module b.
:- import_module c.
\end{myverbatim}
into one if you wish:
\begin{myverbatim}
:- import_module a, b, c.
\end{myverbatim}

\section{Mutually Dependent Modules}

Mercury has no problem with module @a@ importing module @b@ while at the
same time module @b@ imports module @a@.

The Mercury standard library modules @float@ and @math@, for example,
are mutually dependent.  The @float@ module defines the basic operations
on floating point numbers and uses the type @math.domain_error@ to
report things like division by zero.  The @math@ module defines more
complex floating point operations, such as the trignometric functions,
but necessarily depends upon the operations defined in the @float@
module.

\section{Overloading and Module Qualified Names}

Reusing the same name withing the same module.

Reusing the same name as exported by a different module.

\section{The Top-Level Module}

Every program must have a top-level module that exports a @main/2@
predicate with the following signature:
\begin{myverbatim}
:- pred main(io, io).
:- mode main(di, uo) is det.
\end{myverbatim}
(where @io@ is a non-module qualified synonym for @io.state@.)
@main/2@ is the starting point for any Mercury program.

If the top-level module is called @foo@, say, then one can compile the
program into an executable with just
\begin{myverbatim}
> mmc --make foo
\end{myverbatim}
This will recompile only the modules that have been changed since the
last time they were compiled, along with any modules that import them.
In this way, recompilation time for large projects is kept to a minimum.

Chapter \XXX{} discusses the Mercury compiler and related tools in
detail.



\section{Abstract Types}



\section{Submodules}



\subsection{Nested Submodules}



\subsection{Separate Submodules}



\section{Conclusion}
