% vim: ft=tex ff=unix ts=4 sw=4 et tw=76

\chapter{Basic Types}

\XXX{ZS: explain that static typing is one end of a continuum.}

Mercury is both strongly and statically typed.  Strong typing ensures
that a program does not inadvertently compare apples with oranges, while
the purpose of static typing is to inform the programmer \emph{at
compile time} if a given program may attempt such a thing.  Types also
exist to provide a systematic way to structure data.

By way of comparison with other languages, C is not
strongly typed, since C allows unchecked \emph{casts} between values of
different types (a cast is a way of telling the compiler to
treat a particular value as if it had a different type.)

Python is strongly typed, but not statically type checked: every time a
Python program performs an addition, for instance, the arguments have to
be tested to verify that they are indeed numbers.

Java, on the other hand, \emph{is} both strongly and statically typed.
Unfortunately, however, Java's type system lacks expressive power:
\emph{checked} run time casts are frequently necessary, meaning that most
non-trivial type errors will only be spotted when a running program aborts
with an exception.

Mercury does not have these problems.  All type errors in
a Mercury program are identified at compile time, making it harder to
ship buggy programs.  An expressive type system makes Mercury programs more
efficient, since no type checks are needed at run time.  The extra
information also allows the compiler to perform optimizations that would
otherwise be impossible.  (Mercury \emph{also} makes what's known as
\emph{run-time type information} available to a program, which means it is
possible to write programs that are aware of the names and structures of
types.  The predicates @io.read@ and @io.write@ use this facility, for
example, to read and write values of arbitrary types.)

There are three different sorts of type in Mercury: discriminated
unions, equivalence types and abstract types.  A \emph{discriminated
union} is a collection of values.  An
\emph{equivalence type} is simply a different name for another type.  An
\emph{abstract type} is one whose definition is hidden from its users
(abstract types are explained fully in chapter \XXX{} on the module system.)

Every predicate and function in a Mercury program must have a \emph{type
signature} given by the corresponding @pred@ or @func@ declaration.  The
type signature specifies what type each argument has.  The Mercury
compiler uses this information to automatically infer the types of the local
variables in predicate and function definitions and to resolve potential
ambiguity when the same name has been used for more than one purpose (\eg
one might have a data constructor and a predicate with the same name, but
different argument types.)

Because Mercury's type system is rich there is a danger of confusing the
reader with too much, too soon.  This chapter concentrates on the basics,
namely the primitive (built-in) types, defining new \emph{discriminated
union} types, and equivalence types.  More complex aspects of the type
system are dealt with in later chapters \XXX{}.

\section{The Primitive Types}

Mercury's built-in types are @int@, @float@, @char@, @string@, tuples and
the predicate and function types.

\subsection{Integers}

The @int@ type represents the integers -- @123@, @-9@, @42@ and so forth --
that will fit into a machine word on the target computer (the range is from
about $-2$ billion to $+2$ billion on a 32-bit machine.)

All the core operations one can perform on @int@s, including the basic
arithmetic functions, are defined in the @int@ module in the Mercury
standard library.

Like most languages, Mercury has syntax for hexadecimal, octal, and binary
numbers, as well as for the integer codes for characters.  The interested
reader can find the details in the Mercury Reference Manual \XXX{}.

\subsection{Floating Point Numbers}

Floating point values such as @2.718@ and @3.0e8@ ($3.0\times10^8$) are
encoded by the @float@ type.  (The decimal point must always
appear in a floating point number and be preceded and followed by at
least one digit.)

The core @float@ operations are defined in the @float@ module in the
Mercury standard library.  Mathematical constants such as $\pi$ and $e$, and
things like trignometric functions, are defined in the @math@ module in the
Mercury standard library.

\subsection{Characters}

The @char@ type represents single characters.  Unfortunately, due to the
Mercury's heritage, there is no special syntax for single character
values.  Some characters, @a@, @b@, @c@, @1@, @2@, @3@ and so forth,
need no special quoting.
For others (space, tab and newline, for instance), one has to use
single quotes and write @' '@, @'\t'@ and
@'\n'@ -- single quote and backslash are @'\''@ and
@'\\'@ respectively.
Finally, some characters need to be enclosed in parentheses since
otherwise they might be confused with infix operators: @(+)@ and
@(*)@, for example.
The safest method is to use both parentheses \emph{and} quoting, as in
@('/')@.  We apologise for the inconvenience.

The core @char@ operations are defined in the @char@ module in the
Mercury standard libarary.

\XXX{ZS: Fix the language on this point.}

\XXX{ZS: Include a table of escaped characters.}

\subsection{Strings}

Mercury strings are immutable sequences of characters.  Examples include
@"bodacious"@ and @"new\nline"@.  To embed certain characters in a
string -- double quotes, backslashes, tabs and newlines
et cetera -- one has to \emph{escape} them with a preceding backslash:
@\"@, @\\@, @\t@ and @\n@.

If a string contains an explicit newline, as in
\begin{myverbatim}
    "there's a newline in here
there it is"
\end{myverbatim}
then the newline character is actually part of the string, just as
if we had written
\begin{myverbatim}
    "there's a newline in here\nthere it is"
\end{myverbatim}
However, if the \emph{last} character on a line is a non-escaped backslash
then the trailing newline is not taken to be part of the string, hence
\begin{myverbatim}
    "I see \
no newline"
\end{myverbatim}
is the same as
\begin{myverbatim}
    "I see no newline"
\end{myverbatim}

\XXX{I don't really want to mention the double-double quotes in a string
thing.}

It is even possible to include characters in a string by giving the
appropriate character code, although the reader is referred to the Mercury
Reference Manual \XXX{} for details.

The core @string@ operations are defined in the @string@ module in the
Mercury standard library.

\section{Discriminated Union Types}

One can think of a discriminated union as being a set of values, each of
which is distinguishable from the others.  At their core, virtually all
Mercury types are distributed unions.
(Equivalence types are simply a means of giving convenient names to
complicated types and abstract types are used to hide the
definition of a type.)
\XXX{Should I qualify this by saying that types implemented in foreign
code aren't strictly DUs?}

We can define a new type to represent the suits in a deck of playing
cards like this:
\begin{myverbatim}
:- type suit ---> spades ; hearts ; diamonds ; clubs.
\end{myverbatim}
The new type is called @suit@ and it has four 
\emph{data constructors}, or possible values: @spades@, @hearts@,
@diamonds@ and @clubs@.  The goal
\begin{myverbatim}
    X = spades
\end{myverbatim}
will, assuming @X@ is uninstantiated, bind @X@ to the value @spades@ which
is of type @suit@.

Data constructors can take arguments, as illustrated by the following type
for binary trees of @int@s:
\begin{myverbatim}
:- type int_tree ---> empty ; branch(int, int_tree, int_tree).
\end{myverbatim}
The code for insertion and the membership test can be written like
this:
\begin{myverbatim}
:- func insert(int, int_tree) = int_tree.

insert(X, empty          ) = branch(X, empty, empty).

insert(X, branch(Y, L, R)) =
    (      if X =< Y then branch(Y, insert(X, L), R)
      else /* X  > Y */   branch(Y, L, insert(X, R))
    ).

:- pred int_tree `contains` int.
:- mode in       `contains` in is semidet.

branch(X, L, R) `contains` Y :-
    (   Y = X
    ;   Y < X,  L `contains` Y
    ;   Y > X,  R `contains` Y
    ).
\end{myverbatim}
(Observe the C-style @/*@ comment @*/@ in the definition of @insert/2@.)

As we've seen before, a data constructor in a program denotes either a
construction or a deconstruction -- exactly which is determined by the
modes and the context.  In @insert/2@, occurrences of @branch/3@ and
@empty@ in the head are deconstructions, while occurrences in the body are
constructions.

The definition for @contains/2@ uses a plain disjunction, not a switch:
it reads ``a @branch(X, L, R)@ contains @Y@ \emph{iff} @Y = X@
\emph{or} @Y < X@ and @L@ contains @Y@ \emph{or} @Y > X@ and @R@
contains @Y@.''
If any arm of the disjunction succeeds then the predicate as a
whole succeeds.  A clause for the @empty@ case is not necessary since it
would always fail.

It is quite common for a type to have a single constructor of the same
name:
\begin{myverbatim}
:- type date ---> date(int, int, int).  % Year, month, day.
\end{myverbatim}
Mercury will never get the type and the data constructor confused since
the type name can only appear in type declarations and the constructor
name can only appear in clauses.

\subsection{Parameterised Discriminated Union Types}

So far we've only described ``concrete'' types.  It turns out to be very
useful to generalise over whole families of types.  The binary
tree \emph{structure} used in @int_tree@, for instance, would also work
fine for strings, floating
point numbers and pretty much anything else.  Rather than defining
nearly identical types (\eg @string_tree@ and @float_tree@) every time
we need them, it is far better to \emph{parameterise} our definition, thus:
\begin{verbatim}
:- type tree(T) ---> empty ; branch(T, tree(T), tree(T)).
\end{verbatim}
A value of type @tree(T)@, then, is either @empty@ or a @branch(X, Y, Z)@
where @X@ is of type @T@ and @Y@ and @Z@ are of type @tree(T)@.

Since we are now working over arbitrary types rather than plain @int@s, we
need to use \emph{generic} comparison predicates for the insert and look-up
operations:
\begin{verbatim}
:- func insert(T, tree(T)) = tree(T).

insert(X, empty          ) = branch(X, empty, empty).

insert(X, branch(Y, L, R)) =
    (      if X @=< Y then branch(Y, insert(X, L), R)
      else /* X @>  Y */   branch(Y, L, insert(X, R))
    ).

:- pred tree(T) `contains` T.
:- mode in      `contains` in is semidet.

branch(X, L, R) `contains` Y :-
    O = ordering(X, Y),
    (   O = (=)
    ;   O = (<),    R `contains` Y
    ;   O = (>),    L `contains` Y
    ).
\end{verbatim}
The predicates, \verb!@<!, \verb!@=<!, \verb!@>=!, and \verb!@>!, 
compare two terms in Mercury's \emph{standard ordering}.
It doesn't matter what that ordering is for our purposes here, although the
curious reader can find out more from the Mercury Reference Manual
\XXX{Put this documentation in the Refence Manual!}.
The function
@ordering(X, Y)@ returns @(=)@ if @X = Y@, @(<)@ if \verb!X @< Y!, and
@(>)@ if \verb!X @> Y!.

We can substitute any type we like for the parameter @T@ in @tree(T)@:
@tree(int)@ is a binary tree of integers, @tree(string)@ is a binary tree of
strings, and so on.  The implementations for @insert/2@ and @contains/2@
will work regardless of which type is substituted for @T@, something we
could not have managed if we'd stuck to using @int_tree@, @string_tree@
and so forth.
Moreover, Mercury will tell us at compile time if we ever attempt to insert
a @string@, say, into a @tree(int)@ (compare this with Java, say, where such
a problem would only become apparent when the running program threw an
exception.)

A type may have more than one parameter.  We might want to
generalise our @tree/1@ type to store arbitrary key-value mappings to form a
dictionary structure:
\begin{verbatim}
:- type dict(K, V)
    --->    empty
    ;       branch(K, V, dict(K, V), dict(K, V)).
\end{verbatim}
The insert and lookup operations are similar to their @tree/1@ counterparts:
\begin{verbatim}
:- func insert(K, V, dict(K, V)) = dict(K, V).

insert(Ka, Va, empty) =
    branch(Ka, Va, empty, empty).

insert(Ka, Va, branch(Kb, Vb, L, R)) = Tree :-
    O = ordering(Ka, Kb),
    (   O = (=),    Tree = branch(Ka, Va, L, R)
    ;   O = (<),    Tree = branch(Kb, Vb, insert(Ka, Va, L), R)
    ;   O = (>),    Tree = branch(Kb, Vb, L, insert(Ka, Va, R))
    ).

:- pred lookup(dict(K, V), K,  V).
:- mode lookup(in,         in, out) is semidet.

lookup(branch(Ka, Va, L, R), Kb, Vb) :-
    O = ordering(Ka, Kb),
    (   O = (=),    Vb = Va
    ;   O = (<),    lookup(R, Kb, Vb)
    ;   O = (>),    lookup(L, Kb, Vb)
    ).
\end{verbatim}
It is a requirement that any type variables appearing in a data constructor
in a type definition must be parameters of the type.  The following
violates the rule and would be reported as an error:
\begin{verbatim}
:- type awful ---> mistake(T).
\end{verbatim}
The justification is that Mercury has to be able to work out what type @X@
has in @mistake(X)@ in every deconstruction.
This definition,
were it legal, says that @X@ could be anything at all
-- there is, in general, simply no way for the compiler to work out the
actual type ahead of time.
(Chapter \XXX{} explains existentially quantified types which \emph{can} be
used to construct heterogeneous collections.)

\subsection{Lists}

Lists are a particular discriminated union type that are used more often
than any other.  A list is essentially a linear sequence of data.  Mercury
provides special syntax for lists, which is the topic of this subsection
(chapter \XXX{} discusses programming with lists in detail.)

We could define a list type like this:
\begin{myverbatim}
:- type list(T) ---> empty ; cons(T, list(T)).
\end{myverbatim}
where @cons/2@ stands for ``list constructor''.  In a term of the form
@cons(X, Xs)@, @X@ is referred to as the \emph{head} and @Xs@ is referred to
as the \emph{tail}.  Under this scheme, the list of the numbers @1, 2, 3@
would be represented as @cons(1, cons(2, cons(3, empty)))@.  However, this
syntax is too cumbersome for regular use.

The @list@ module in the Mercury standard library defines the type @list/1@
like this:
\begin{myverbatim}
:- type list(T) ---> [] ; [T | list(T)].
\end{myverbatim}
The empty list is represented by @[]@ and the non-empty list is represented
by @[X | Xs]@ where @X@ is the head and @Xs@ is the tail.

The term @[X | Xs]@ is syntactic sugar for @[|](X, Xs)@ -- the two forms are
completely interchangable.

The term @[1, 2, 3]@ is syntactic sugar for @[1 | [2 | [3 | []]]]@.

The term @[1, 2 | Xs]@ is syntactic sugar for @[1 | [2 | Xs]]@.

The unsugared notation is virtually never used in practice.

\subsection{Tuples}

Sometimes a small group of predicates needs to exchange parcels of data, such
as pairs of strings and numbers.  It can be annoying to have to define a new
type such as
\begin{myverbatim}
:- type string_and_int ---> string_and_int(string, int).
\end{myverbatim}
when the type is only used in a very limited scope.  One alternative is to
use a \emph{tuple}.

Tuples are the only primitive compound type in Mercury.  A tuple is any
number of comma-separated values between braces:
\begin{myverbatim}
    {"the base of natural logarithms", 'e', 2.718}
\end{myverbatim}
This tuple has type @{string, char, float}@.

There is no tuple-specific library module: one can construct them and
one can deconstruct them -- and that's it.

\section{Equivalence Types}

Imagine we are writing a personnel database relating people to lists of
various attributes and that we have already defined the types @person@ and
@attribute@.
The @dict/2@ type defined above is a likely candidate for the job.
Specifically, we'd want to use
\begin{verbatim}
    dict(person, list(attribute))
\end{verbatim}
This is something of a mouthful.  Typing this everywhere we needed it would be
tiring and, worse, a maintenance problem if we later decide that, say,
@set(attribute)@ is a better idea than @list(attribute)@.

The Mercury solution to the problem is to use an equivalence type:
\begin{verbatim}
:- type persattrs == dict(person, list(attribute)).
\end{verbatim}
and hereafter we can write @persattrs@ as shorthand for the type on the
right hand side of the @==@ symbol.  It makes no difference to Mercury
whether you use @persattrs@ or the full type name.

A common idiom is to use equivalence types to give use-specific names
to primitive types.  For instance
\begin{verbatim}
:- type name         == string. % Must be non-empty.
:- type age          == int.    % Must be non-negative.
:- type num_children == int.    % Must be non-negative.
\end{verbatim}
@type@, @pred@ and @func@ declarations that use these names
appropriately become much more readable.

Equivalence types may also be parameterised.  For example, the following
describes a suitable representation for graph structures with labelled
vertices:
\begin{verbatim}
:- type graph(T) == map(vertex(T), list(vertex(T))).
\end{verbatim}
(We assume the type @vertex/1@ has been defined elsewhere.)
\XXX{Do we need more explanation of this type?  Or a simpler example?}

Note that, as with discriminated union types, any type variable appearing on
the right hand side of the @==@ must also appear as a parameter on the left
hand side.  Thus the following is in error:
\begin{verbatim}
:- type woeful == list(T).
\end{verbatim}

\XXX{Should I mention the shadow-types ``pattern''?}

\section{Conclusion}

Some sort of conclusion.



\chapter{More About Types}

\XXX{Not sure yet quite where this chapter will appear.}

The chapter on basic types \XXX{} explained the main primitive
types and how one can define new discriminated union types and equivalence
types.  Chapter \XXX{} on modules explained abstract types.

This chapter covers several more advanced type related topics, including how
to give names to data constructor fields and how to specify your own
equality and comparison relations.

(The chapters on type classes \XXX{} and the run-time type information
system \XXX{} complete the description of the Mercury type system.)

\section{Data Constructors with Named Fields}

Like most languages, Mercury supports data structures with named fields.
Consider a type used to keep track of the tally of votes:
\begin{myverbatim}
:- type tally ---> tally(ayes :: int, nayes :: int).
\end{myverbatim}
naming the fields of the @tally/2@ data constructor @ayes@ and
@nayes@ respectively.  We can still construct and deconstruct @tally/2@
values as if it had been defined without named fields.  However, having
named fields also allows us to refer to them \emph{without} the need for an
explicit deconstruction.

\subsection{Accessing Fields}

If we have @X = tally(12, 7)@ then we can refer to the values of the fields
of the value bound to @X@ using @X ^ ayes@ and @X ^ nayes@:
\begin{myverbatim}
    X ^ ayes  = 12,
    X ^ nayes =  7
\end{myverbatim}
The expression @X ^ ayes@ is just syntactic sugar for @ayes(X)@.  The
function @ayes/1@ is automatically constructed from the field name in the
type definition and will be defined as
\begin{myverbatim}
ayes(tally(A, _)) = A.
\end{myverbatim}

\subsection{Updating Fields}

We can ``update'' a particular field like this:
\begin{myverbatim}
    Y = ( X ^ ayes := 13 )
\end{myverbatim}
giving @Y = tally(13, 7)@.  This, of course, does not affect the value
of @X@: we still have @X = tally(12, 7)@.  
@X ^ ayes := 13@ should be read as ``the value of @X@ with @13@
substituted in the @ayes@ field.''

The expression @X ^ ayes := 13@ is just syntactic sugar for
@'ayes :='(X, 13)@.  The function @'ayes :='/2@ is also automatically
constructed from the type definition.  (Anything at all can be used as a
functor name if it is enclosed in @'@single quotes@'@, which is why the
extra characters in the name do not lead to trouble.)  The definition of
the automatically created @'ayes :='/2@ would be
\begin{myverbatim}
'ayes :='(tally(_, B), A) = tally(A, B).
\end{myverbatim}

Updating several fields in one go is straightforward:
\begin{myverbatim}
    Z = (( Y ^ ayes  := Y ^ ayes  + 2 )
             ^ nayes := Y ^ nayes + 3 )
\end{myverbatim}
giving @Z = tally(15, 10)@.

\subsection{Restrictions on Field Names}

At the time of writing, Mercury requires that no field name be defined twice
in the same module in order to avoid problems with ambiguity.  The following
are therefore all errors.

This example is illegal because it uses the same field name twice in the
same data constructor:
\begin{verbatim}
:- type foo ---> foo(a :: int, a :: int).
\end{verbatim}
Because the module qualified forms of the name will be different, there is
no problem with different \emph{modules} using the same field name.

The next example uses the same field name in two different data
constructors and is therefore illegal, despite the fact that they belong to
the same type:
\begin{verbatim}
:- type foo ---> foo1(a :: int)
            ;    foo2(a :: int).
\end{verbatim}
Finally, one cannot use the same field name twice, even in different types:
\begin{verbatim}
:- type foo ---> foo(a :: int).
:- type bar ---> bar(a :: int).
\end{verbatim}

(The names @foo@, @bar@, @baz@ and @quux@ are conventionally used by
computer scientists when they can't think of anything better to use in an
example.)

\subsection{Fields Within Fields}

Consider the following:
\begin{myverbatim}
:- type car
    --->    car(
                make            :: string,
                registration    :: string,
                owner           :: person
            ).

:- type person
    --->    person(
                name            :: string,
                date_of_birth   :: date,
                address         :: string
            ).
\end{myverbatim}
(we assume @date@ is defined elsewhere) and the bindings
\begin{myverbatim}
    Fred = person(
               "Fred Bloggs",
               date(1965, 7, 4),
               "11 Strangetrousers Terrace"
           ),
    Car  = car( 
               "Ford Escort",
               "PQR 123",
               Fred
           )
\end{myverbatim}
We can obtain the @name@ of the @owner@ of @Car@ with
@Car ^ owner ^ name@:
\begin{myverbatim}
    Car ^ owner ^ name = "Fred Bloggs"
\end{myverbatim}
So @Car ^ owner ^ name@ is the same as writing @(Car ^ owner) ^ name@.

If Fred moves house and we need to update his address then we can write
\begin{myverbatim}
    Car1 = (Car ^ owner ^ address := "42 Strawberry Fields")
\end{myverbatim}
which is the same as if we'd written
\begin{myverbatim}
    Owner  = Car ^ owner,
    Owner1 = (Owner ^ address := "42 Strawberry Fields"),
    Car1   = (Car   ^ owner   := Owner1                )
\end{myverbatim}
So the parentheses matter.  If we just wanted an updated version of the
@owner@ field of @Car@, rather than an updated version of @Car@ itself,
we'd write
\begin{myverbatim}
    Owner1 = ((Car ^ owner) ^ address := "42 Strawberry Fields")
\end{myverbatim}
which this time is the same as having written
\begin{myverbatim}
    Owner  = Car ^ owner,
    Owner1 = (Owner ^ address := "42 Strawberry Fields")
\end{myverbatim}

\subsection{User-Defined Field Access Functions}

It can be useful to explicitly define functions to be used for field access,
either to provide ``virtual'' fields that are computed rather than stored
(C$\sharp$ calls such things \emph{properties}), or to provide sanity checks
on accesses and updates, or to define ``indexed fields''.

\subsubsection{Virtual Fields}

Say we want to add a ``virtual'' field to the @person@ type, computing the
number of children a particular individual has.
To do this we simply write
\begin{verbatim}
:- func person ^ num_children = int.

Person ^ num_children = list.length(Person ^ children).
\end{verbatim}
(Virtual field access functions do not represent real fields, of course, and
so don't appear as field names in the type definition.)

\subsubsection{Checked Fields}

We can add a sanity check to the @children@ field's update function
ensuring that a person never \emph{loses} children when the list is updated:
(here we are just providing our own definition for the @children/2@ field
access function; Mercury will not construct a definition for a field access
or update function if we have already given one)
\begin{myverbatim}
:- func (person ^ children := list(child)) = person.

(person(A, B, C, D0, E) ^ children := D) = Person :-
    ( if all [Child] (
            list.member(Child, D0) => list.member(Child, D)
      ) 
      then Person = person(A, B, C, D, E)
      else exception.throw("you can't unhave children!")
    ).
\end{myverbatim}
(The condition of the conditional goal reads ``for all @Child@, \emph{if}
@Child@ is a member of @D0@ \emph{then} @Child@ must be a member of @D@.'')

Say we have 
\begin{myverbatim}
    Homer = person(
               "Fred Bloggs",
               date(1966, 4, 9),
               "Evergreen Terrace",
               [lisa, bart],
               [ /* no secrets */ ]
           )
\end{myverbatim}
and there is a new addition to the family.  If we write
\begin{myverbatim}
    Homer1 = (Homer ^ children := [lisa, bart, maggie])
\end{myverbatim}
then the update proceeds as expected.  On the other hand, forgetting one of
Homer's existing children in the update, as in
\begin{myverbatim}
    Homer1 = (Homer ^ children := [bart, maggie])
\end{myverbatim}
will result in the update operation throwing an exception since @lisa@ is a
member of @Homer ^ children@, but not @[bart, maggie]@.

\subsubsection{Indexed Fields}

We can also add ``virtual, indexed'' fields.  If we wish to
access a @person@'s @children@ by number we might write
\begin{verbatim}
:- func person ^ child(int) = child.

Person ^ child(N) = list.index0_det(Person ^ children, N).
\end{verbatim}
where @list.index0_det(Children, N)@ returns the @N@th member of @Children@,
(counting from zero, in traditional computer science style) or
throws an exception if @N@ is out of range.

Under this scheme we get
\begin{myverbatim}
    Homer ^ child(0) = lisa
    Homer ^ child(1) = bart
\end{myverbatim}
but @Homer ^ child(2)@, for instance, will throw an exception.

(The expression @Person ^ child(N)@ is syntactic sugar for
@child(N, Person)@.)

\XXX{Should I mention @map.elem/2@ etc. here as examples?}

Virtul indexed fields may have any number of arguments.  For example, the
two-dimensional array module (for instance, @array2d@ in the Mercury
standard library, defines @Array2D ^ elem(I, J)@ to access the element at
row @I@, column @J@ of @Array2D@.)
array.

\subsection{Mixing Named and Unnamed Fields}

It is not necessary to name every field in a data constructor:
\begin{myverbatim}
:- type person
    --->    person(
                name            :: string,
                date_of_birth   :: date,
                address         :: string,
                children        :: list(child),
                /* secrets */      list(secret)
            ).
\end{myverbatim}
The @list(secret)@ field is not named and, unlike the named fields, can
therefore only be accessed by deconstruction and ``updated'' by
construction.

\subsection{Semideterministic Field Access}

Consider the following type:
\begin{myverbatim}
:- type data ---> empty ; datum(payload :: int, rest :: data).
\end{myverbatim}
Given an @X@ of type @data@, the expression @X ^ payload@, may
\emph{fail}.  The field access @X ^ payload@ can only succeed if @X@ is
bound to a @datum/2@ value -- if @X@ is bound to @empty@ then there is no
@payload@ field.

Field accesses for field names that do not occur in all the data
constructors of a type are therefore \emph{semideterministic}.  Be aware of
his point, as it can from time to time lead to confusing error messages from
the compiler.

\XXX{Do I need to say anything about using pattern matching to resolve the
issue?}

\section{Explicit Type Qualification}

The types of the \emph{head variables} in a clause (\ie those appearing in
the clause head) are given by the corresponding @pred@ or @func@
declaration.  The compiler deduces the types of the \emph{local} variables
via a process known as \emph{type inference}.  Very occasionally, type
inference alone is not sufficient to unambiguously decide the type of a
local variable.

\subsection{Name Ambiguity}

Sometimes these problems arise due to overloaded names \XXX{this term is
introduced in the ``Hello, World!'' chapter}.  Say we have a module
@a@ exporting a predicate @num/1@,
\begin{myverbatim}
:- module a.
:- interface.

:- pred num(int).
:- mode num(out) is multi.

:- implementation.

num(1).
num(2).
num(3).
\end{myverbatim}
and a module @b@ exporting a predicate also called @num/1@,
\begin{myverbatim}
:- module b.
:- interface.

:- pred num(float).
:- mode num(out) is multi.

:- implementation.

num(1.414).
num(2.718).
num(3.141).
\end{myverbatim}
and a third module that imports both @a@ and @b@, defining a predicate @p@
testing whether there are solutions for @num/1@ whose sum is also a
solution:
\begin{myverbatim}
:- import int, float, a, b.

:- pred p.
:- mode p is semidet.

p :-
    num(X),
    num(Y),
    num(X + Y).
\end{myverbatim}
Since the code here does not module qualify @num/1@, the compiler cannot
decide if the programmer means @a.num/1@ and @int.(+)/2@ or @b.num/1@ and
@float.(+)/2@.

There are two ways to solve the problem: \emph{either} explicitly
module qualify the names (not always convenient) \emph{or} add
explicit type qualifiers to local variables or expressions to provide
the compiler with sufficient information.  Explicit
type qualification connects an expression to a type via the @with_type@
keyword.  The type ambiguity in @p@ above can be fixed with
\begin{myverbatim}
p :-
    num(X `with_type` int),
    num(Y `with_type` int),
    num((X + Y) `with_type` int).
\end{myverbatim}
although this is overkill.  In fact only one type qualification is
necessary, for instance
\begin{myverbatim}
p :-
    num(X),
    num(Y),
    num((X + Y) `with_type` int).
\end{myverbatim}
The compiler will reason that since the result of @X + Y@ must be an
@int@, the addition is a call to @int:(+)/2@.  This means that @X@ and @Y@
must also have type @int@ (since the type of @int:(+)/2@ is
@func(int, int) = int@) and therefore that the calls to @num/1@ must refer
to @a.num/1@ (and not @b.num/1@ which has type @pred(float)@.)

\subsection{Type Ambiguity}

Here is an example of type ambiguity that arises for different reasons:
\begin{myverbatim}
main(!IO) :-
    io.read(Result, !IO),
    (
        Result = ok(X),
        io.print(X, !IO)
    ;
        Result = eof
    ;
        Result = error(_, _),
        throw(Result)
    ).
\end{myverbatim}
The predicates @io.read/3@ and @io.print/3@ read and write values of
virtually \emph{any} type.  However, the compiler needs to be able to work
out the type of @X@ before it can compile @main/2@ (chapter \XXX{} on
run-time type information explains why this is the case.)  Our program,
however, gives no clue as to what type @X@ is supposed to have and the
compiler will issue an error message of the form
\begin{myverbatim}
oops.m:017: In predicate `oops.main/2':
oops.m:017:   warning: unresolved polymorphism.
oops.m:017:   The variables with unbound types were:
oops.m:017:       X: T
oops.m:017:       Result: (io.read_result(T))
\end{myverbatim}

Let's say we intended @X@ to be an @int@.
To resolve this problem we need to add an explicit type qualifier to @X@
-- because @X@ can never change its type it doesn't matter where --
and it's usually a good idea to pick the first occurrence:
\begin{myverbatim}
main(!IO) :-
    io.read(Result, !IO),
    (
        Result = ok(X `with_type` int),
        io.print(X, !IO)
    ;
        ...
    ).
\end{myverbatim}

\section{Type Specialised Predicates and Functions}

\XXX{To go in the optimization chapter.}

Polymorphic predicates that test parameterised values for equality or
compare them against each other have to pay a small performance penalty.

The Mercury compiler transparently constructs specialised equality and
comparison predicates for every type in a program.  These predicates are
passed as ``hidden'' arguments in each call to a polymorphic predicate or
function.

Consider the following function:
\begin{myverbatim}
:- func max(T, T) = T.

max(X, Y) = ( if X @=< Y then Y else X ).
\end{myverbatim}
The call to @max/2@ in the goal @Max = max(Foo, Bar)@ includes a hidden
argument giving the equality and comparison predicates for the specific type
that @Foo@ and @Bar@ share.  This information is passed to the call to
\verb!@=</2! which makes use of the comparison predicate.

As with all higher order programming, there is a small cost associated with
passing and using these hidden arguments.  For the most part, the cost is
trivial.  However, in some very rare circumstances performance requirements
may dictate that, say, a version of @max/2@ specialised for integer
arguments be used.

Mercury lets us do this without altering the definitions in our program.  We
merely add the following line to the module defining @max/2@:
\begin{myverbatim}
:- pragma type_spec(max/2, T = int).
\end{myverbatim}
This causes Mercury to construct a specialised version of @max/2@ as if it
had been declared as
\begin{myverbatim}
:- func max(int, int) = int.
\end{myverbatim}
(obtained by applying the substitution @T = int@ to the original function
declaration)
and all calls to @max/2@ where the compiler knows that the arguments must be
@int@s will use this version rather than the polymorphic version.
Because this version isn't polymorphic, the compiler can replace the call to
\verb!@=</2! in the definition with the
@int@ version, @=</2@, and avoid the overhead of an higher order predicate
call.

The reader is referred to the Mercury Reference Manual \XXX{} for complete
information on the @type_spec@ pragma.

\section{Types with User Defined Equality}

\XXX{This could conceivably go in the chapter on advanced modes.}

\XXX{Want to add a paragraph explaining that this is black-belt stuff and
can be skimmed over by the faint of heart.}

Imagine we wish to define a type to represent sets.  For whatever reasons
(e.g. we expect most sets to be small) we decide to use lists containing no
duplicates:
\begin{myverbatim}
:- type set(T) ---> set(list(T)).   % No duplicates in list.

:- func list_to_set(list(T)) = set(T).

list_to_set(Xs) = set(remove_dups(Xs)).

:- func remove_dups(list(T)) = list(T).

remove_dups([]      ) = [].
remove_dups([X | Xs]) =
    ( if list.member(X, Xs) then remove_dups(Xs)
                            else [X | remove_dups(Xs)] ).
\end{myverbatim}
This representation raises a problem: every set with more than two members
can be represented in multiple ways.  That is, the set ${1, 2, 3}$ can be
represented in any one of six ways:
\begin{myverbatim}
    [1, 2, 3]
    [1, 3, 2]
    [2, 1, 3]
    [2, 3, 1]
    [3, 1, 2]
    [3, 2, 1]
\end{myverbatim}
This is going to cause problems.  We would like it to be true that
\begin{myverbatim}
    list_to_set([1, 2, 3]) = list_to_set([3, 2, 1])
\end{myverbatim}
Unfortunately, as things stand, this isn't true.

One way around the problem is to revisit our design and perhaps use sorted
lists without duplicates instead.  This approach not be compatible with our
reasons for choosing unsorted lists in the first place.

The alternative is to supply our own equality predicate and tell Mercury to
use that, rather than use the default:
\begin{myverbatim}
:- type set(T) ---> set(list(T))
    where equality is equals_set.

:- pred equals_set(set(T), set(T)).
:- mode equals_set(in,     in    ) is semidet.

equals_set(A, B) :-
    A `subset_of` B,
    B `subset_of` A.

:- pred set(T) `subset_of` set(T).
:- mode in     `subset_of` in      is semidet.

set(As) `subset_of` set(Bs) :-
    all [X] ( list.member(X, As) => list.member(X, Bs) ).
\end{myverbatim}
The modifier @where equality is equals_set@ on the type definition for
@set/1@ tells Mercury to use @equals_set/2@ rather than the standard
equality test when testing two @set/1@ values for equality.  It is the
responsibility of the programmer to ensure that the type specific equality
predicate really does define an equivalence relation (\ie it should be
reflexive, symmetric and transitive).

Any attempt to examine the representation of a type with user defined
equality is, conceptually, non-deterministic (because any particular value
of such a type may have multiple representations.)  This means that Mercury
has to place certain restrictions on such code to ensure that programs have
sound semantics.

The constraints are these and they apply to deconstructions of values whose
types have user defined equality:
\begin{itemize}
\item such a deconstruction that does not appear as a ``discriminator'' in a
switch must be guaranteed to succeed (\ie you can't have non-switching
deconstructions if the type has more than one data constructor);
\item a switch whose ``discriminators'' are such deconstructions must be
exhaustive (\ie there must be one arm of the switch for every data
constructor);
\item deconstructions or switches of this sort have determinism @cc_multi@
(see chapter \XXX{} on advanced modes.)
\end{itemize}
Code with determinism @cc_multi@ cannot be backtracked into (the compiler
will report an error), which makes user defined equality quite restrictive.

The following, for instance, is in error:
\begin{myverbatim}
:- pred set(T) `contains` T.
:- mode in     `contains` in is semidet.

set(Xs) `contains` X :- list.member(X, Xs).
\end{myverbatim}
@set/1@ has only the one data constructor, @set/1@, hence the deconstruction
of the left hand argument in the head is guaranteed to succeed.
Since @set/1@ has user defined equality this deconstruction has determinism
@cc_multi@ and cannot be backtracked over.
@list.member/2@ is @semidet@ and therefore \emph{may} cause the program to
backtrack over the deconstruction.  Consequently this predicate definition
is invalid.

The way around the problem is as follows:
\begin{myverbatim}
:- pred set(T) `contains` T.
:- mode in     `contains` in is semidet.

Set `contains` X :-
    promise_only_one_solution(contains_2(Set, X)) = yes.

:- pred contains_2(set(T), T,  bool).
:- mode contains_2(in,     in, out) is cc_multi.

contains_2(set(Xs), X, Result) :-
    Result = ( if list.member(X, Xs) then yes else no ).
\end{myverbatim}
The built-in function @promise_only_one_solution/1@ takes a @cc_multi@
closure with one output as its argument (the closure
@contains_2(Set, X)@ has type @pred(bool)@ since the first two arguments
have already been supplied) and returns the result as if the computation
were deterministic.  It is up to the programmer to ensure that the promise
is correct -- rest assured that strange bugs will eventually appear in your
program if you lie to the compiler.

(@contains_2@ is valid because its definition cannot fail and hence will
never backtrack over the deconstruction of its first argument.)

In summary, types with user-defined equality can be very useful.  However,
the programmer has to write in a somewhat constrained style to make it work.

\section{Types with User Defined Comparison}

\XXX{This could conceivably go in the chapter on advanced modes.}

\XXX{Want to add a paragraph explaining that this is black-belt stuff and
can be skimmed over by the faint of heart.}

Just as it is sometimes useful to specify a particular equality relation for
a type, it can also be useful to specify a particular ordering relation.

The example we will use this time is for an alternative representation for
strings that favours fast -- $O(1)$ -- concatenation:
\begin{myverbatim}
:- type str ---> string(string) ; str ++ str.

:- func to_string(str) = string.

to_string(Str) = string.append_list(to_string_list(Str, [])).

:- func to_string_list(str, list(string)) = list(string).

to_string_list(string(S),    Ss) = [S | Ss].
to_string_list(StrA ++ StrB, Ss) =
    to_string_list(StrA, to_string_list(StrB, Ss)).
\end{myverbatim}
So we use @string(S)@ to turn the string @S@ into a @str@ and
@StrA ++ StrB@ to denote the concatenation of @StrA@ and @StrB@.  The
function @to_string/1@ converts @str@ values into ordinary strings.

A natural thing to want to do is to compare (representations of) strings.
Unfortunately for our purposes, the default Mercury ordering has
\begin{myverbatim}
    s("ZYX")  @<  s("A") ++ s("BC")
\end{myverbatim}
rather than the other way around as we would prefer.

Mercury allows us to provide our own comparison predicate for @str@ values
to be used in place of the built-in ordering:
\begin{myverbatim}
:- type str ---> string(string) ; str ++ str
    where comparison is compare_str.

:- pred compare_str(comparison_result, str, str).
:- mode compare_str(out,               in,  in ) is det.

compare_str(O, StrA, StrB) :-
    O = ordering(to_string(StrA), to_string(StrB)).
\end{myverbatim}
The type @comparison_result@ is built-in and defined thus:
\begin{myverbatim}
:- type comparison_result ---> (<) ; (=) ; (>).
\end{myverbatim}
The requirement for a three-place predicate with the comparison result
argument being computed in the first argument is due to historical reasons.
The built-in function @ordering/2@ is just a more convenient way of calling
the built-in predicate @compare/3@:
\begin{myverbatim}
ordering(A, B) = O :-
    compare(O, A, B).
\end{myverbatim}
Supplying a user-defined comparison relation causes Mercury to use the
given predicate rather than the default ordering.

It is the programmer's duty to ensure that the user defined comparison
predicate does define a total ordering and agrees with the equality
relation.
That is
\begin{itemize}
\item #ordering(A, B)# is always defined,
\item it is always the case that #ordering(A, A) = (=)#,
\item if #A @< B# then #B @> A# and vice versa,
\item if #A @< B# and #B @< C# then #A @< C# (and similarly for #@>#), and
\item if #A = B# then #ordering(A, B) = (=)# and vice versa.
\end{itemize}

Finally, it is possible to specify both an equality predicate and a
comparison predicate for the same type:
\begin{myverbatim}
:- type str ---> string(string) ; str ++ str
    where equality is equals_str, ordering is compare_str.
\end{myverbatim}
This is occasionally useful when the equality test can be implemented more
cheaply than comparison.

\section{Conclusion}

\XXX{Some kind of summary.}

\section{Function and Predicate Types}

\XXX{To go in the HO chapter.}

Functions and predicates are first class citizens in the Mercury type
system: they can be passed as arguments, returned as results
and stored in other data structures.  This aspect of Mercury is
discussed in detail in chapter \XXX{} on higher order programming.

Function and predicate types look just like the corresponding @func@ and
@pred@ declarations with the name is omitted.
The @func@ declaration for @math.sqrt/1@, for example, is given as
\begin{myverbatim}
:- func sqrt(float) = float.
\end{myverbatim}
The type of @math.sqrt/1@ is therefore @func(float) = float@.

The @pred@ declaration for @set.contains/2@, which tests whether a
particular value is a member of a set, is declared as
\begin{myverbatim}
:- pred contains(set(T), T).
\end{myverbatim}
so @set.contains/2@ has the type @pred(set(T), T)@.
The @T@ is a \emph{type parameter} (about which we will say more
in a little while) meaning we can substitute any type at all for @T@ and
the predicate will still work.

\XXX{Since this will be in the HO chapter, it needs rewording.}

Although we haven't yet covered higher order programming (see chapter
\XXX{}), we should still be able to understand higher order type
signatures.  @string.words/2@, for instance, has the type
\begin{myverbatim}
    func(pred(char), string) = list(string)
\end{myverbatim}
indicating that its first argument is a predicate over characters.
(Note that the \emph{type} of a function or predicate says nothing about
its \emph{mode} -- which arguments are inputs and its determinism and so
forth.  Modes are the subject of chapter \XXX{}.)

\section{Abstract Types}

\XXX{To go in the modules chapter.}

It's not always a good to reveal the \emph{definition} of a type to its
users.  For one thing, doing so means one cannot later change the
definition of the type without the risk of breaking other programs that use
it.  It is a good engineering principle to hide 
implementation detail from users wherever possible.

The @dict/2@ dictionary data type we defined in chapter \XXX{} on basic
types is a good candidate for a library module that we can re-use over and
over again.  The implementation details of @dict/2@ are not important to the
users of the module: they will only be interested in the functionality on
offer.  Furthermore, we want the freedom to change the definition of
@dict/2@ at some later point if we find a more efficient representation --
and we want to be able to do so without requiring existing users to make
changes to their code.

The solution to the problem is to make @dict/2@ an \emph{abstract type}.
\begin{myverbatim}
:- module dict.
:- interface.


:- type dict(K, V).     % Abstract type.

:- func new_dict = dict(K, V).

:- func insert(K, V, dict(K, V)) = dict(K, V).

:- pred lookup(dict(K, V), K,  V  ).
:- mode lookup(in,         in, out) is semidet.


:- implementation.


:- type dict(K, V)      % Definition of abstract type.
    --->    empty
    ;       branch(K, V, dict(K, V), dict(K, V)).

new_dict = empty.

...
\end{myverbatim}
The line @:- type dict(K, V).@ declares @dict/2@ to be an abstract type:
an abstract type is just one whose type declaration omits the definition.
The full type definition instead appears in the implementation section.

Since the users of an abstract type have no idea how it is defined, they can
neither create values of that type directly via construction nor examine
them with pattern matching (deconstruction).  The only way to manipulate
such values is to use the operations exported by the module defining the
abstract type.

This module includes the function @new_dict@ so that users can create new,
empty @dict/2@ values in the first place (functions of arity zero are just
fixed values.)
Other than that, users can only extend @dict/2@ values with @insert/3@ and
examine them with @lookup/3@.
The following is therefore wrong:
\begin{myverbatim}
:- import_module dict.

this_wont_compile :-
    Dict0 = empty,
    Dict1 = branch("Gateau", 'x', Dict0, Dict0),
    ...
\end{myverbatim}
because the implementation section of the @dict@ module is the \emph{only}
place that knows what the @dict/2@ data constructors are.  This, however, 
is fine:
\begin{myverbatim}
:- import_module dict.

this_will_compile :-
    Dict0 = new_dict,
    Dict1 = dict.insert("Gateau", 'x', Dict0),
    ...
\end{myverbatim}
